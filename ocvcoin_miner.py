#!/usr/bin/env python3

import urllib.request
import urllib.error
import urllib.parse
import base64
import json
import hashlib
import random
import time
import os
import sys
import secrets
import ssl
import platform
import re

import configparser
import math


from pycl import *
from pycl import _dll_filename
from array import array
from datetime import datetime
from threading import Thread , Timer

import threading
import binascii
import socket
import selectors
import operator
import socketserver
import argparse

from test_framework.segwit_addr import (
    decode_segwit_address
)
from test_framework.blocktools import (
    create_block,
    NORMAL_GBT_REQUEST_PARAMS,
    script_BIP34_coinbase_height,
    add_witness_commitment
)
from test_framework.messages import (
    CBlock,
    CBlockHeader,
    BLOCK_HEADER_SIZE,
)
from test_framework.messages import (
    CBlock,
    COIN,
    COutPoint,
    CTransaction,
    CTxIn,
    CTxOut
)



















CURRENT_MINER_VERSION = "1.0.3.7"

## OUR PUBLIC RPC
OCVCOIN_PUBLIC_RPC_URL = "https://rpc.ocvcoin.com/OpenRPC.php"

RPC_SERVERS = []



## PRIMARY RPC SERVER
RPC_URL = OCVCOIN_PUBLIC_RPC_URL
RPC_USER = "" 
RPC_PASS = "" 


RPC_SERVERS.append([RPC_URL,RPC_USER,RPC_PASS])



rpc_config = r"""###<GENERATED BY OCVCOIN MINER>###
###DO NOT EDIT THIS BLOCK###
###SHOULD BE AT THE BEGINNING OF THE FILE###
[main]
rpcuser=ocvcoinrpc
rpcpassword="""+secrets.token_urlsafe(32)+"""
rpcallowip=0.0.0.0/0
rpcbind=0.0.0.0
rpcport=8332
server=1
###</GENERATED BY OCVCOIN MINER>###"""


rpc_check_regexp = r"""^\s*###<GENERATED BY OCVCOIN MINER>###\s*\n\s*###DO NOT EDIT THIS BLOCK###\s*\n\s*###SHOULD BE AT THE BEGINNING OF THE FILE###\s*\n\s*\[main\]\s*\n\s*rpcuser=ocvcoinrpc\s*\n\s*rpcpassword=(\S+)\s*\n\s*rpcallowip=0\.0\.0\.0/0\s*\n\s*rpcbind=0\.0\.0\.0\s*\n\s*rpcport=8332\s*\n\s*server=1\s*\n\s*###</GENERATED BY OCVCOIN MINER>###\s+"""

ocvcoin_core_restart_warning = """

Please restart Ocvcoin Core!

"""

MAX_HASHRATE = {}
WORK_ID = 0
LATEST_TARGET_HEIGHT = 0


def build_merkle_root(coinbase_hash_bin, merkle_branch):
    merkle_root = coinbase_hash_bin
    for h in merkle_branch:
        merkle_root = hashlib.sha256(hashlib.sha256(merkle_root + binascii.unhexlify(h)).digest()).digest()
    return binascii.hexlify(merkle_root).decode('utf-8')


def build_block_header(params,extranonce,extranonce2):


    
   
    prevhash = bytes.fromhex(params[1])

    p0 = prevhash[0:4][::-1]
    p1 = prevhash[4:8][::-1]
    p2 = prevhash[8:12][::-1]
    p3 = prevhash[12:16][::-1]

    p4 = prevhash[16:20][::-1]
    p5 = prevhash[20:24][::-1]
    p6 = prevhash[24:28][::-1]
    p7 = prevhash[28:32][::-1]    
       
    prevhash = (p0 + p1 + p2 + p3 + p4 + p5 + p6 + p7).hex()
    
    coinbase1 = params[2]
    coinbase2 = params[3]
    merkle_branch = params[4]
    version = params[5]
    nbits = params[6]
    ntime = params[7]    

    version = bytes.fromhex(version)[::-1].hex()
    ntime = bytes.fromhex(ntime)[::-1].hex()
    nbits = bytes.fromhex(nbits)[::-1].hex()
    
    

    
    coinbase = coinbase1 + extranonce + extranonce2 + coinbase2
    coinbase_hash_bin = hashlib.sha256(hashlib.sha256(bytes.fromhex(coinbase)).digest()).digest()


    
    
    
    merkle_root = build_merkle_root(coinbase_hash_bin, merkle_branch)









    block_header = ''.join([version, prevhash, merkle_root, ntime, nbits, "00000000"])
    
    return block_header


def diff_to_target_alternate(difficulty):

    def _target(target):
        return '%064x' % target
        
        

    if difficulty == 0:
        target = 2 ** 256 - 1
    else:
        target = min(int((0xffff0000 * 2 ** (256 - 64) + 1) / difficulty - 1 + 0.5), 2 ** 256 - 1)


    return _target(target)

def diff_to_target(diff):

    def chunks(l, n):
        for i in range(0, len(l), n):
            yield l[i:i+n]

    BASE_DIFFICULTY = 0x00000000FFFF0000000000000000000000000000000000000000000000000000    

    target = ''.join(list(chunks('%064x' % int(BASE_DIFFICULTY / diff), 2)))


    return target




def block_bits2target(bits):
    """
    Convert compressed target (block bits) encoding to target value.

    Arguments:
        bits (string): compressed target as an ASCII hex string

    Returns:
        bytes: big endian target
    """

    # Bits: 1b0404cb
    #       1b          left shift of (0x1b - 3) bytes
    #         0404cb    value
    bits = bytes.fromhex(bits)
    shift = bits[0] - 3
    value = bits[1:]

    # Shift value to the left by shift
    target = value + b"\x00" * shift
    # Add leading zeros
    target = b"\x00" * (32 - len(target)) + target

    return target


__m4p_min_pay_already_set_list = {}
def stratum_print_url():    
    
    global STRATUM_GLOBALS,STRATUM_CONNECTIONS,OCVCOIN_ADDR_TAKEN_FROM_ARG,__m4p_min_pay_already_set_list,GLOBAL_STATS  

    pool_page = None
    m4p_solo_ports = [3379,23379,13379,33379]
    
    if "mining4people" in STRATUM_GLOBALS["host"]:
    
        if STRATUM_GLOBALS["port"] in m4p_solo_ports:
        
            if OCVCOIN_ADDR_TAKEN_FROM_ARG != None:
                pool_page = "https://mining4people.com/pool/ocvcoin-solo/account/"+OCVCOIN_ADDR_TAKEN_FROM_ARG
            else:
                pool_page = "https://mining4people.com/pool/ocvcoin-solo"    
                
        else:
        
            if OCVCOIN_ADDR_TAKEN_FROM_ARG != None:
                pool_page = "https://mining4people.com/pool/ocvcoinpplns/account/"+OCVCOIN_ADDR_TAKEN_FROM_ARG
            else:
                pool_page = "https://mining4people.com/pool/ocvcoinpplns"
                
                
    elif "phalanxmine" in STRATUM_GLOBALS["host"]: 
        if OCVCOIN_ADDR_TAKEN_FROM_ARG != None:
            pool_page = "https://pool.phalanxmine.com/?address="+OCVCOIN_ADDR_TAKEN_FROM_ARG
        else:
            pool_page = "https://pool.phalanxmine.com/site/all_coins?coin=OCV"

    if pool_page == None:
        return

    while True:
    
        
        print("\n\033[92m\nStats: "+pool_page+"\n\033[00m\n")
    
    
        if GLOBAL_STATS["ar"][0] > 100:
        
            if "mining4people" in STRATUM_GLOBALS["host"]:
                if STRATUM_GLOBALS["port"] not in m4p_solo_ports:        


                    for device_group_name in STRATUM_CONNECTIONS:
                        if CONFIG[device_group_name]["reward_addr"] not in __m4p_min_pay_already_set_list:


                            try:


                                external_ip = urllib.request.urlopen('https://checkip.amazonaws.com/').read().decode('ascii').strip()


                                data = json.dumps({"ipAddress":external_ip,"settings":{"paymentThreshold":10}}).encode()
                                request = urllib.request.Request("https://mining4people.com/api/pools/ocvcoinpplns/account/"+CONFIG[device_group_name]["reward_addr"]+"/settings",data,headers={
                                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; rv:109.0) Gecko/20100101 Firefox/115.0",
                                    "Accept": "application/json",
                                    "Accept-Language": "en-US,en;q=0.5",
                                    "Content-Type": "application/json",
                                    "Sec-Fetch-Dest": "empty",
                                    "Sec-Fetch-Mode": "cors",
                                    "Sec-Fetch-Site": "same-origin",
                                    "Pragma": "no-cache",
                                    "Cache-Control": "no-cache"
                                })
                                sslfix_context = ssl._create_unverified_context()        
                                f = urllib.request.urlopen(request,context=sslfix_context,timeout=20)
                                
                            
                                time.sleep(10)
                                
                                
                                __m4p_min_pay_already_set_list[CONFIG[device_group_name]["reward_addr"]] == True
                            except Exception as e:
                                pass   






           
        
        time.sleep(120)        


def stratum_print_stats():    
    
    global STRATUM_GLOBALS  


    def unique(list1):
     
        # initialize a null list
        unique_list = []
     
        # traverse for all elements
        for x in list1:
            # check if exists in unique_list or not
            if x not in unique_list:
                unique_list.append(x)
                
        return unique_list



    while True:
        time.sleep(30)
        
        with STRATUM_GLOBALS["log_lock"]:
        
            
            p = "\n\033[92m\n"

            methods = unique(list(STRATUM_GLOBALS["fail_count"].keys()) + list(STRATUM_GLOBALS["success_count"].keys()))
            for method in methods:
            
                succ = 0
                if method in STRATUM_GLOBALS["success_count"]:
                    succ = STRATUM_GLOBALS["success_count"][method]

                fail = 0
                if method in STRATUM_GLOBALS["fail_count"]:
                    fail = STRATUM_GLOBALS["fail_count"][method]

                if succ > 0:
                    if fail > 0:
                        rate = (100 * succ) / (succ + fail)
                    else:
                        rate = 100
                else:
                    rate = 0
                
            
                p = p + method+":"+str(succ+fail)+"/"+str(fail)+" (%"+str(int(rate))+")\n"
                if method in STRATUM_GLOBALS["err"]:
                    for errkey in STRATUM_GLOBALS["err"][method]:
                        p = p + "     "+str(errkey)+":"+str(STRATUM_GLOBALS["err"][method][errkey])+"\n"
            
            
            p = p + "\n\033[00m\n"
            print(p)

def stratum_reconnect(dgn):

    global STRATUM_GLOBALS,STRATUM_CONNECTIONS


    if STRATUM_CONNECTIONS[dgn]["connect_lock"].acquire(blocking=False):  # Try to acquire the lock without blocking
        try:      

        
            print("connecting...")
            try:
                STRATUM_CONNECTIONS[dgn]["sock"].shutdown()
                STRATUM_CONNECTIONS[dgn]["sock"].close()
            except Exception as e:
                pass           
            while True:
                try:




                    STRATUM_CONNECTIONS[dgn]["sock"] = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    
                    if STRATUM_GLOBALS["ssl"]:
                        sslfix_context = ssl._create_unverified_context()
                        STRATUM_CONNECTIONS[dgn]["sock"] = sslfix_context.wrap_socket(STRATUM_CONNECTIONS[dgn]["sock"])
                    STRATUM_CONNECTIONS[dgn]["sock"].connect((STRATUM_GLOBALS["host"], STRATUM_GLOBALS["port"]))

                    #stratum_suggest_target(dgn)
                    stratum_subscribe(dgn)
                    stratum_authorize(dgn)
                    
                    pass_attr = getattr(PRGARGS, 'pass')
                    if pass_attr != None and pass_attr != "" and not re.match(re.compile('.*?d=\d+.*?', re.UNICODE), pass_attr):                    
                        stratum_suggest_difficulty(dgn)
                        
                        
                    break
                    
                    
                except Exception as e:
                    print("exception in stratum_reconnect:")
                    print(repr(e))                     
                    time.sleep(5)




        finally:
            STRATUM_CONNECTIONS[dgn]["connect_lock"].release()
    

    







def stratum_safe_extranonce2(dgn):
    global STRATUM_CONNECTIONS
    
    with STRATUM_CONNECTIONS[dgn]["extranonce2_lock"]:
        STRATUM_CONNECTIONS[dgn]["last_extranonce2"] = STRATUM_CONNECTIONS[dgn]["last_extranonce2"] + 1  
        ret = STRATUM_CONNECTIONS[dgn]["last_extranonce2"]
        
    return ret


def stratum_safe_rpc_id():

    global STRATUM_GLOBALS
    
    with STRATUM_GLOBALS["rpc_id_lock"]:
        STRATUM_GLOBALS["last_rpc_id"] = STRATUM_GLOBALS["last_rpc_id"] + 1  
        ret = STRATUM_GLOBALS["last_rpc_id"]
        
    return ret
    
    
def stratum_safe_sendall(dgn,data):

    global STRATUM_CONNECTIONS
    #print(data)
    with STRATUM_CONNECTIONS[dgn]["sendall_lock"]:
        STRATUM_CONNECTIONS[dgn]["sock"].sendall(data) 

   

def stratum_subscribe(dgn):

    global STRATUM_GLOBALS
    
    uagent = "github.com/ocvcoin/gpuminer " + "v" + CURRENT_MINER_VERSION
    
    req_id = stratum_safe_rpc_id()
    
    STRATUM_GLOBALS["id2method"][req_id] = "mining.subscribe"
    
    session_id = None
        
    
    
    subscribe_request = {
        "id": req_id,
        "method": "mining.subscribe",
        "params": [uagent,session_id]
    }
    
    stratum_safe_sendall(dgn,json.dumps(subscribe_request).encode(encoding="ascii",errors="ignore") + b'\n')
    


def stratum_authorize(dgn):        


    global STRATUM_GLOBALS,STRATUM_CONNECTIONS
    
    req_id = stratum_safe_rpc_id()
    
    STRATUM_GLOBALS["id2method"][req_id] = "mining.authorize"
    
    worker_name = STRATUM_CONNECTIONS[dgn]["worker_name"]
    
    pass_attr = getattr(PRGARGS, 'pass')
    if pass_attr != None and pass_attr != "":  
        password = pass_attr
    else:    
        password = STRATUM_GLOBALS["pass"]+",d={:.6f}".format(STRATUM_CONNECTIONS[dgn]["set_diff"])
    
    authorize_request = {
        "id": req_id,
        "method": "mining.authorize",
        "params": [worker_name, password]
    }
    stratum_safe_sendall(dgn,json.dumps(authorize_request).encode(encoding="ascii",errors="ignore") + b'\n')


def stratum_suggest_difficulty(dgn):   

    global STRATUM_GLOBALS,STRATUM_CONNECTIONS
    
    req_id = stratum_safe_rpc_id()
    
    STRATUM_GLOBALS["id2method"][req_id] = "mining.suggest_difficulty"
    
    request = {
        "id": req_id,
        "method": "mining.suggest_difficulty",
        "params": [STRATUM_CONNECTIONS[dgn]["set_diff"]]
    }
    
    stratum_safe_sendall(dgn,json.dumps(request).encode(encoding="ascii",errors="ignore") + b'\n')
	
def stratum_suggest_target(dgn):        

    global STRATUM_GLOBALS,STRATUM_CONNECTIONS
    
    req_id = stratum_safe_rpc_id()
    
    STRATUM_GLOBALS["id2method"][req_id] = "mining.suggest_target"
    
    request = {
        "id": req_id,
        "method": "mining.suggest_target",
        "params": [diff_to_target_alternate(STRATUM_CONNECTIONS[dgn]["set_diff"])]
    }
    
    stratum_safe_sendall(dgn,json.dumps(request).encode(encoding="ascii",errors="ignore") + b'\n')	


def stratum_process_line(dgn,line):

    global STRATUM_GLOBALS,STRATUM_CONNECTIONS,GLOBAL_STATS
    
    #print(line)
    
    
    response = json.loads(line.decode(encoding="ascii",errors="ignore"))
    
    if response["id"] not in STRATUM_GLOBALS["id2method"]:
        if "method" in response:
            method = response["method"]
        else:
            method = "null"
    else:
        method = STRATUM_GLOBALS["id2method"][response["id"]]
        del STRATUM_GLOBALS["id2method"][response["id"]]
    
    if 'error' in response and response['error'] is not None:
    
        with STRATUM_GLOBALS["log_lock"]:    
        
            if type(response['error']) == str:
                err = response['error']
            elif "message" in response['error']:
                err = response['error']["message"]

            elif type(response['error']) is list:
                try:
                    err = response['error'][1]
                except Exception as e: 
                    try:
                        err = response['error'][0]
                    except Exception as e:  
                        err = "unknown?"

            else:    
                err = "unknown?"
            
            err = re.sub('[0-9]+', '.', err)
        
            if method not in STRATUM_GLOBALS["fail_count"]:
                STRATUM_GLOBALS["fail_count"][method] = 0
            STRATUM_GLOBALS["fail_count"][method] = STRATUM_GLOBALS["fail_count"][method] + 1
            
            
            if method == "mining.submit":
                GLOBAL_STATS["ar"][1] = GLOBAL_STATS["ar"][1] + 1
        
            if method not in STRATUM_GLOBALS["err"]:
                STRATUM_GLOBALS["err"][method] = {}
            
            if err not in STRATUM_GLOBALS["err"][method]:
                STRATUM_GLOBALS["err"][method][err] = 0    
            STRATUM_GLOBALS["err"][method][err] = STRATUM_GLOBALS["err"][method][err] + 1
    
    else:
    
        with STRATUM_GLOBALS["log_lock"]:
        
            if method not in STRATUM_GLOBALS["success_count"]:
                STRATUM_GLOBALS["success_count"][method] = 0
            STRATUM_GLOBALS["success_count"][method] = STRATUM_GLOBALS["success_count"][method] + 1
            
            
    
    
        if method == "mining.subscribe":
            STRATUM_CONNECTIONS[dgn]["subscribe"] = response["result"]
            STRATUM_CONNECTIONS[dgn]["work_id"] = STRATUM_CONNECTIONS[dgn]["work_id"] + 1
        elif method == "mining.set_target":            
            STRATUM_CONNECTIONS[dgn]["target"] = bytes.fromhex(response["params"][0])
            print("target changed to {}".format(response["params"][0]))
            
        elif method == "mining.notify":            
            STRATUM_CONNECTIONS[dgn]["notify"] = response["params"]              
            STRATUM_CONNECTIONS[dgn]["work_id"] = STRATUM_CONNECTIONS[dgn]["work_id"] + 1
            print("new job: {}".format(response["params"][0]))
    
        elif method == "mining.set_difficulty":            
            STRATUM_CONNECTIONS[dgn]["target"] = bytes.fromhex(diff_to_target_alternate(float(response["params"][0])))
            print("target changed to {}".format(response["params"][0]))
        elif method == "client.reconnect":            
            
            print("server requested reconnection to {}:{}".format(response["params"][0],response["params"][1]))
            STRATUM_GLOBALS["host"] = response["params"][0]
            STRATUM_GLOBALS["port"] = response["params"][1]
            if response["params"][2] is not None:   
                
                t = Timer(response["params"][2], stratum_reconnect,[dgn])
                
                t.daemon = True
                
                t.start()                
            else:
                stratum_reconnect(dgn)
    

def stratum_listen_lines(dgn):

    global STRATUM_GLOBALS,STRATUM_CONNECTIONS
    
    while True:
        try:           

            sel = selectors.DefaultSelector()
            sel.register(STRATUM_CONNECTIONS[dgn]["sock"], selectors.EVENT_READ)

            buffer = b""

            while True:
                events = sel.select()
                for key, mask in events:
                    if mask & selectors.EVENT_READ:
                        data = STRATUM_CONNECTIONS[dgn]["sock"].recv(1024)
                        if not data:
                            
                            sel.unregister(STRATUM_CONNECTIONS[dgn]["sock"])
                            STRATUM_CONNECTIONS[dgn]["sock"].close()
                            raise Exception("connection closed!") 
                            

                        buffer += data
                        while b'\n' in buffer:
                            line, buffer = buffer.split(b'\n', 1)
                            stratum_process_line(dgn,line)
        except Exception as e:
            print("exception in stratum_listen_lines loop:")
            print(repr(e))          
            
            time.sleep(5)
            stratum_reconnect(dgn)







_loop_start_val = {} 
def stratum_ocl_mine_ocvcoin(device_index):       
    
    global STRATUM_CONNECTIONS,PYCL_QUEUE,PYCL_KERNEL,MAX_HASHRATE,_loop_start_val,GLOBAL_STATS
    

    dgn = DEVICE_ID2GROUP[device_index]


    if device_index not in _loop_start_val:
        _loop_start_val[device_index] = 1

    if device_index not in MAX_HASHRATE:
        MAX_HASHRATE[device_index] = 0
    
      

    local_work_items = abs(int(CONFIG[dgn]["number_of_local_work_items"]))
    
    if local_work_items % 32 != 0:
        local_work_items = int(local_work_items / 32) * 32    
    if local_work_items == 0:
        local_work_items = 32
    
    global_work_size = abs(int(CONFIG[dgn]["number_of_global_work_items"])) 
    if global_work_size % 256 != 0:
        global_work_size = (int(global_work_size / 256) + 1) * 256
    

    
    
    
    if CONFIG[dgn]["loop_count"] != "auto":
        loop_count = abs(int(CONFIG[dgn]["loop_count"]))
        if loop_count < 1:
            loop_count = 1
        elif loop_count > 256:
            loop_count = 256      
        
    else:
        
        loop_count = _loop_start_val[device_index]






        
    

    
    current_work_id = STRATUM_CONNECTIONS[dgn]["work_id"] 
    current_target = STRATUM_CONNECTIONS[dgn]["target"]    
    
    sub_details,extranonce1,extranonce2_size = STRATUM_CONNECTIONS[dgn]["subscribe"]    
    
    job_id,prevhash,coinb1,coinb2,merkle_branch,version,nbits,ntime,clean_jobs = STRATUM_CONNECTIONS[dgn]["notify"] 
    
    extranonce2 = int2lehex(stratum_safe_extranonce2(dgn), extranonce2_size).hex()
    
    block_header = build_block_header(STRATUM_CONNECTIONS[dgn]["notify"],extranonce1,extranonce2)
    

    if current_work_id != STRATUM_CONNECTIONS[dgn]["work_id"]:
        return
    


    
        


    
    block_header = bytes.fromhex(block_header)    
    
    

    


       
        
    printd(device_index,"starting to mine job_id: "+str(job_id))
    
    
  
    

    start_hash = block_header[0:76]
    
    final_init_img = bytearray()

    i = 0
    while i < 27:
        start_hash = hashlib.sha512(start_hash).digest()
        final_init_img = final_init_img + start_hash
        i += 1

    # Create buffers    
    target_diff_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', current_target), blocking=True)
    init_img_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', final_init_img), blocking=True)
    block_header_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', block_header), blocking=True)
    
    output_buf_arr = array('B', b'\x00' * 32)    
    output_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], output_buf_arr, blocking=True)    
    
    

    
    MAX_HASHRATE[device_index] = 0    
    
    
    
    
    current_step = 0
    

    
    start_time = time.time()
    total_hashed = 0
    skip_hashrate_calculation = False
    
    while True:
    
    
        if skip_hashrate_calculation == True:
            start_time = time.time()
            total_hashed = 0
            skip_hashrate_calculation = False
        
        
        calc_per_time = loop_count*global_work_size

        last_time_stamp = time.time()
        
        total_hashed = total_hashed + calc_per_time                            
        
        run_evt = PYCL_KERNEL[device_index](current_step, loop_count, target_diff_buf, init_img_buf, block_header_buf, output_buf).on(PYCL_QUEUE[device_index], global_work_size,lsize=local_work_items)

        output_bin, evt = buffer_to_pyarray(PYCL_QUEUE[device_index], output_buf, wait_for=run_evt, like=output_buf_arr) 

      
        

        # Wait for all events to complete
        evt.wait()
        
        nonce_bytes = output_bin.tobytes()

        

        if nonce_bytes[4] > 0:

            skip_hashrate_calculation = True

            send_nonce = nonce_bytes[0:4][::-1].hex()

            

            printd(device_index,"found! submitting: {}\n".format(nonce_bytes[0:4].hex()))  
  
            req_id = stratum_safe_rpc_id()
            
            STRATUM_GLOBALS["id2method"][req_id] = "mining.submit"
            
            payload = '{"params": ["'+STRATUM_CONNECTIONS[dgn]["worker_name"]+'", "'+str(job_id)+'", "'+ extranonce2 +'", "'+str(ntime)+'", "'+send_nonce+'"], "id": '+str(req_id)+', "method": "mining.submit"}\n'
            
            while True:
                try:            
                    stratum_safe_sendall(dgn,payload.encode(encoding="ascii",errors="ignore"))
                    break
                except Exception as e:
                    printd(device_index,"exception in mining.submit loop:")
                    printd(device_index,repr(e))
                    time.sleep(5)
                    stratum_reconnect(dgn)



            GLOBAL_STATS["ar"][0] = GLOBAL_STATS["ar"][0] + 1

            
            clReleaseMemObject(output_buf)
            output_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], output_buf_arr, blocking=True) 

        if skip_hashrate_calculation != True:

            current_timestamp = time.time()
            diff = current_timestamp - last_time_stamp
            
            hash_rate = int(calc_per_time / diff)         
            
            
            
            total_diff = current_timestamp - start_time            
            total_hash_rate = int(total_hashed / total_diff)            
            
            if MAX_HASHRATE[device_index] < hash_rate:
                MAX_HASHRATE[device_index] = hash_rate
                
            GLOBAL_STATS["hs"][DEVICEID2STATINDEX[device_index]] = hash_rate    
                
            printd(device_index,"now: {}, avg: {}, max: {} hash/s (loop_count:{})".format(hash_rate,total_hash_rate,MAX_HASHRATE[device_index],loop_count))
            
             
            
            if current_step > 1 and (diff > 3  or diff < 1): 
                

                recommended_val = math.ceil((2 * loop_count) / diff)
                if recommended_val > 256:
                    recommended_val = 256
                if recommended_val < 1:
                    recommended_val = 1            
                   
                
                if CONFIG[dgn]["loop_count"] == "auto":                
                    

                    if loop_count != recommended_val:
                        printd(device_index,"fixing check interval... setting loop_count {} to {} ...".format(loop_count,recommended_val))
                    loop_count = recommended_val
                    _loop_start_val[device_index] = recommended_val
                              
                
                
                
        
        
        
        if STRATUM_CONNECTIONS[dgn]["work_id"] != current_work_id:
            printd(device_index,"new work detected!")
            clReleaseMemObject(target_diff_buf)
            clReleaseMemObject(init_img_buf)
            clReleaseMemObject(block_header_buf)
            clReleaseMemObject(output_buf)        
            return
        current_step = current_step + 1
        
        if (current_step*global_work_size + global_work_size) > 0xFFFFFF:
            printd(device_index,"no more nonce!")
            clReleaseMemObject(target_diff_buf)
            clReleaseMemObject(init_img_buf)
            clReleaseMemObject(block_header_buf)
            clReleaseMemObject(output_buf)            
            return

        if current_target != STRATUM_CONNECTIONS[dgn]["target"]:
            current_target = STRATUM_CONNECTIONS[dgn]["target"]
            clReleaseMemObject(target_diff_buf)
            target_diff_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', current_target), blocking=True)            
            













def stratum_miner(device_index):
    
    global STRATUM_CONNECTIONS,PYCL_CTX,PYCL_QUEUE,PYCL_PROGRAM,PYCL_KERNEL

    
    dgn = DEVICE_ID2GROUP[device_index]
    

    while True:
        try:     


            while STRATUM_CONNECTIONS[dgn]["subscribe"] == None or STRATUM_CONNECTIONS[dgn]["notify"] == None or STRATUM_CONNECTIONS[dgn]["target"] == None:
                print(".", end ="")
                time.sleep(0.05)

            
            stratum_ocl_mine_ocvcoin(device_index)                         
            
        except Exception as e:
            printd(device_index,"exception in stratum_miner loop:")
            printd(device_index,repr(e)) 
            
            
            try:
                clReleaseKernel(PYCL_KERNEL[device_index])
            except Exception as e:
                pass
            try:
                clReleaseKernel(PYCL_PROGRAM[device_index])
            except Exception as e:
                pass                
            try:
                clReleaseKernel(PYCL_QUEUE[device_index])
            except Exception as e:
                pass                
            try:
                clReleaseKernel(PYCL_CTX[device_index])
            except Exception as e:
                pass                
                
                
                
                
                
            build_kernel(device_index)
            
            
            
            
            time.sleep(1)








       
       
def stratum_timed_check(i,host,port,timeout,is_ssl):

    global STRATUM_SERVER_PINGS

    def check(host,port,timeout,is_ssl):
        sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)  
        sock.settimeout(timeout)
        
        try:   
        
            if is_ssl:
                sslfix_context = ssl._create_unverified_context()
                sock = sslfix_context.wrap_socket(sock)  
                
            sock.connect((host,port))
            
            ret = True
            
        except Exception as e:
            ret = False
            
        try:
            sock.close()
        except Exception as e:
            pass            
        
        return ret
           



    t0 = time.time()
    if check(host,port,timeout,is_ssl):
       STRATUM_SERVER_PINGS[i] = time.time()-t0        
    else:
        STRATUM_SERVER_PINGS[i] = -1






_clbcc = 0
def check_latest_block():    
    
    global _clbcc,LATEST_TARGET_HEIGHT,LATEST_BLOCK_TEMPLATE,WORK_ID  

    if _clbcc % 200 == 0:
        LATEST_BLOCK_TEMPLATE = rpc_getblocktemplate()
        LATEST_TARGET_HEIGHT = int(LATEST_BLOCK_TEMPLATE["height"])-1
        WORK_ID = WORK_ID + 1
        _clbcc = 0
    else:    
        LATEST_TARGET_HEIGHT = rpc_getblockcount()
        
        if int(LATEST_BLOCK_TEMPLATE["height"]) <= LATEST_TARGET_HEIGHT:
            
            LATEST_BLOCK_TEMPLATE = rpc_getblocktemplate()
            LATEST_TARGET_HEIGHT = int(LATEST_BLOCK_TEMPLATE["height"])-1
            WORK_ID = WORK_ID + 1
            _clbcc = 0

    
    _clbcc = _clbcc + 1
    t = Timer(0.35, check_latest_block)
    
    t.daemon = True
    
    t.start()


  
  
try:
    
    request = urllib.request.Request("https://rpc.ocvcoin.com/",headers={'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.1.15 (KHTML, like Gecko)'})
    sslfix_context = ssl._create_unverified_context()        
    f = urllib.request.urlopen(request,context=sslfix_context,timeout=5)
    EXTRA_SEED = f.read()+bytes(str(f.info()),"utf-8")+bytes(str(time.time()),"ascii")
except Exception as e:
    try:
        EXTRA_SEED = bytes(str(time.time()),"ascii") + bytes(str(e.headers),"utf-8")
    except Exception as e:
        EXTRA_SEED = bytes(str(time.time()),"ascii")
    


def printd(device_index,i):

    now = datetime.now()
    dt_string = now.strftime("%Y-%m-%d %H:%M:%S")
    print("["+str(dt_string)+"] ["+DEVICE_NAMES[device_index]+"] "+str(i))



def check_addr(addr):
    
    version,addrbytes = decode_segwit_address("ocv", addr)
    
    if version != 0 and version != 1:
        return False
    if len(addrbytes) != 20 and len(addrbytes) != 32:
        return False
        
    return True
        







    
def create_coinbase_via_bech32_addr(height, bech32_addr, coinbasevalue, coinbasemsg, extra_output_script=None):
    #accepts bech32 & bech32m addresses
    
    
       
    
    coinbase = CTransaction()
    coinbase.vin.append(CTxIn(COutPoint(0, 0xffffffff), bytes(script_BIP34_coinbase_height(height))+hashlib.sha256(secrets.token_bytes(256)+EXTRA_SEED).digest()[:16]+bytes(coinbasemsg, 'utf-8')[:76], 0xffffffff))
    coinbaseoutput = CTxOut()

    coinbaseoutput.nValue = coinbasevalue
    
    address_decoded = decode_segwit_address("ocv", bech32_addr)

    if address_decoded[0] == 0:
        req_opcode = bytes(b'\x00')
    elif address_decoded[0] == 1:
        req_opcode = bytes(b'\x51')
    else:
        exit("address not supported!")
    
    
    coinbaseoutput.scriptPubKey = req_opcode + int2lehex(len(address_decoded[1]), 1) + bytes(address_decoded[1])
    
    coinbase.vout = [coinbaseoutput]
    if extra_output_script is not None:
        coinbaseoutput2 = CTxOut()
        coinbaseoutput2.nValue = 0
        coinbaseoutput2.scriptPubKey = extra_output_script
        coinbase.vout.append(coinbaseoutput2)
    coinbase.calc_sha256()
    return coinbase
def screen_clear():
   # for mac and linux(here, os.name is 'posix')
   if os.name == 'posix':
      _ = os.system('clear')
   else:
      # for windows platfrom
      _ = os.system('cls')

_print_norepeat_latest_input = ""
def print_norepeat(i):
    global _print_norepeat_latest_input
    if i != _print_norepeat_latest_input:
        _print_norepeat_latest_input = i
        print(i)





def rpc(method, params=None,rpc_index=0):
    """
    Make an RPC call to the Bitcoin Daemon JSON-HTTP server.

    Arguments:
        method (string): RPC method
        params: RPC arguments

    Returns:
        object: RPC response result.
    """

    rpc_id = random.getrandbits(32)
    data = json.dumps({"id": rpc_id, "method": method, "params": params}).encode()   

       
    
    if RPC_SERVERS[rpc_index][0] == OCVCOIN_PUBLIC_RPC_URL:
        if method == "getblocktemplate" or method == "getblockcount":
            request = urllib.request.Request(RPC_SERVERS[rpc_index][0]+"?method="+method)
        else:
            request = urllib.request.Request(RPC_SERVERS[rpc_index][0]+"?method="+method, data)
    else:
        if RPC_SERVERS[rpc_index][1] != "" or RPC_SERVERS[rpc_index][2] != "":
            auth = base64.encodebytes((RPC_SERVERS[rpc_index][1] + ":" + RPC_SERVERS[rpc_index][2]).encode()).decode().strip()
            request = urllib.request.Request(RPC_SERVERS[rpc_index][0], data, {"Authorization": "Basic {:s}".format(auth)})
        else:
            request = urllib.request.Request(RPC_SERVERS[rpc_index][0], data)
    
    err_detected = False
    try:        
                
        sslfix_context = ssl._create_unverified_context()            
        f = urllib.request.urlopen(request,context=sslfix_context,timeout=5)
        response = json.loads(f.read())
        
    except Exception as e:
    
        #print("An exception occurred (RPC)") 
        #print(e)
        err_detected = True
        
    if not err_detected:
    
        if not 'id' in response:
            #print("id missing")
            #print(response)
            err_detected = True
            
        elif (RPC_SERVERS[rpc_index][0] != OCVCOIN_PUBLIC_RPC_URL or method == "submitblock") and response['id'] != rpc_id:
            #print("Invalid response id: got {}, expected {:u}".format(response['id'], rpc_id))
            #print(response)
            err_detected = True

        elif 'error' in response and response['error'] is not None:
            #print("RPC error: {:s}".format(json.dumps(response['error'])))
            err_detected = True
        
        elif not 'result' in response:
            #print("result missing")
            #print(response)
            err_detected = True





        
        
    if err_detected == True:
        if rpc_index == 0:
            if len(RPC_SERVERS) > 1:
                print_norepeat("Public RPC server sometimes not responding! Switching to backup RPC server!")
            else:
                print_norepeat("Public RPC server sometimes not responding! It is recommended to install Ocvcoin Core on your computer!")
        else:
            print_norepeat("The backup RPC server is also not responding! Please restart Ocvcoin Core!")
            
            
        return False
        



    return response['result']


def rpc_getblockcount():
    global LATEST_TARGET_HEIGHT
    
    divider = len(RPC_SERVERS)
    i = divider
    while True:
        rpcindex = i % divider
        #if i > divider:            
            #print("getblockcount" +str(i-divider)+ "th retry...")
            
        ret = rpc("getblockcount",rpc_index=rpcindex)        
            
        if ret != False:
            ret = int(ret)
            if ret >= LATEST_TARGET_HEIGHT:
                break
            #else:    
                #print("getblockcount low! rpc_index: "+str(rpcindex))
                #print("ret >= LATEST_TARGET_HEIGHT")
                #print(str(ret)+"    "+str(LATEST_TARGET_HEIGHT))
                
        #else:
            #print("getblockcount false! rpc_index: "+str(rpcindex))
            
        
        if rpcindex == (divider - 1):
            time.sleep(0.35)        
        
        i = i + 1
    
    return ret

def rpc_getblocktemplate():
    global LATEST_TARGET_HEIGHT
    
    divider = len(RPC_SERVERS)
    i = divider
    while True:
        rpcindex = i % divider
        #if i > divider:            
            #print("getblocktemplate" +str(i-divider)+ "th retry...")

        ret = rpc("getblocktemplate", [NORMAL_GBT_REQUEST_PARAMS],rpcindex)        
            
        if ret != False and "height" in ret:
            gbt_height = int(ret["height"])
            if gbt_height > LATEST_TARGET_HEIGHT:
                break
            #else:    
                #print("getblocktemplate height low! rpc_index: "+str(rpcindex))
                #print("gbt_height > LATEST_TARGET_HEIGHT")
                #print(str(gbt_height)+"    "+str(LATEST_TARGET_HEIGHT))
                
        #else:
            #print("getblocktemplate false! rpc_index: "+str(rpcindex))
            #print(ret)
            

        if rpcindex == (divider - 1):
            time.sleep(0.35)

        i = i + 1
    
    return ret

def rpc_submitblock(block_submission):
    
    global GLOBAL_STATS
    
    divider = len(RPC_SERVERS)
    i = divider
    
    

    soft_errors = {}
    network_errors = {}
    
    while True:
        rpcindex = i % divider
        ret = rpc("submitblock", [block_submission],rpcindex)
        
        if ret is None:
            GLOBAL_STATS["ar"][0] = GLOBAL_STATS["ar"][0] + 1
            return
        elif ret == False:
            if rpcindex in network_errors[rpcindex]:
                network_errors[rpcindex] = network_errors[rpcindex] + 1
            else:
                network_errors[rpcindex] = 1
        else:        
            if rpcindex in soft_errors[rpcindex]:
                soft_errors[rpcindex] = soft_errors[rpcindex] + 1
            else:
                soft_errors[rpcindex] = 1        
        if len(soft_errors) == divider:
            GLOBAL_STATS["ar"][1] = GLOBAL_STATS["ar"][1] + 1
            raise TypeError("rpc_submitblock soft_errors") 
        
        if len(network_errors) == divider:
            is_max_err_count_reached = True
            for x in network_errors:
                is_max_err_count_reached = is_max_err_count_reached and (network_errors[x] > 4)
            if is_max_err_count_reached:
                GLOBAL_STATS["ar"][1] = GLOBAL_STATS["ar"][1] + 1
                raise TypeError("rpc_submitblock network_errors")
        
        for x in soft_errors:
            if soft_errors[x] > 8:
                GLOBAL_STATS["ar"][1] = GLOBAL_STATS["ar"][1] + 1
                raise TypeError("rpc_submitblock soft_error")

        for x in network_errors:
            if network_errors[x] > 8:
                GLOBAL_STATS["ar"][1] = GLOBAL_STATS["ar"][1] + 1
                raise TypeError("rpc_submitblock network_error")
        
        if rpcindex == (divider - 1):
            time.sleep(1)
        


        
        i = i + 1
    
    
    
    
def int2lehex(value, width):
    """
    Convert an unsigned integer to a little endian ASCII hex string.
    Args:
        value (int): value
        width (int): byte width
    Returns:
        string: ASCII hex string
    """

    return value.to_bytes(width, byteorder='little')


_loop_start_val = {} 
def ocl_mine_ocvcoin(device_index):       
    
    global PYCL_QUEUE,PYCL_KERNEL,MAX_HASHRATE,WORK_ID,LATEST_BLOCK_TEMPLATE,LATEST_TARGET_HEIGHT,_loop_start_val,GLOBAL_STATS
    

    if device_index not in _loop_start_val:
        _loop_start_val[device_index] = 1

    if device_index not in MAX_HASHRATE:
        MAX_HASHRATE[device_index] = 0
    
      

    local_work_items = abs(int(CONFIG[DEVICE_ID2GROUP[device_index]]["number_of_local_work_items"]))
    
    if local_work_items % 32 != 0:
        local_work_items = int(local_work_items / 32) * 32    
    if local_work_items == 0:
        local_work_items = 32
    
    global_work_size = abs(int(CONFIG[DEVICE_ID2GROUP[device_index]]["number_of_global_work_items"])) 
    if global_work_size % 256 != 0:
        global_work_size = (int(global_work_size / 256) + 1) * 256
    

    
    
    
    if CONFIG[DEVICE_ID2GROUP[device_index]]["loop_count"] != "auto":
        loop_count = abs(int(CONFIG[DEVICE_ID2GROUP[device_index]]["loop_count"]))
        if loop_count < 1:
            loop_count = 1
        elif loop_count > 256:
            loop_count = 256      
        
    else:
        
        loop_count = _loop_start_val[device_index]






        
    

    
    current_work_id = WORK_ID  
    
    block_template = LATEST_BLOCK_TEMPLATE
    


        
        
    printd(device_index,"starting to mine block: "+str(block_template["height"]))
    
    
    txlist = []
    
    total_len = 0

    for tx in block_template["transactions"]:
    
        total_len = total_len + len(tx["data"])
        
        if total_len > 750000: 
            break
              
        txlist.append(tx["data"])

    
     
  

    coinbase = create_coinbase_via_bech32_addr(block_template["height"], CONFIG[DEVICE_ID2GROUP[device_index]]["reward_addr"], block_template["coinbasevalue"],DEVICE_NAMES[device_index].replace("FULL_PROFILE", "FP").replace("EMBEDDED_PROFILE", "EP").replace(": ", ":") + " {}/{}/{} {} {}".format(global_work_size,local_work_items,loop_count,MAX_HASHRATE[device_index],CURRENT_MINER_VERSION))

    block = create_block( coinbase=coinbase,  tmpl=block_template, txlist=txlist)
    
    
    if len(txlist) > 0:
        add_witness_commitment(block)

    new_block = block.serialize()
    
    block_header = new_block[0:80]  
    

    start_hash = block_header[0:76]
    
    final_init_img = bytearray()

    i = 0
    while i < 27:
        start_hash = hashlib.sha512(start_hash).digest()
        final_init_img = final_init_img + start_hash
        i += 1

    # Create buffers    
    target_diff_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', bytes.fromhex(block_template['target'])), blocking=True)
    init_img_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', final_init_img), blocking=True)
    block_header_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', block_header), blocking=True)
    
    output_buf_arr = array('B', b'\x00' * 32)    
    output_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], output_buf_arr, blocking=True)    
    
    

    
    MAX_HASHRATE[device_index] = 0    
    
    
    
    
    current_step = 0
    

    
    start_time = time.time()
    total_hashed = 0
    skip_hashrate_calculation = False
    
    while True:
    
        if skip_hashrate_calculation == True:
            start_time = time.time()
            total_hashed = 0   
            skip_hashrate_calculation = False
        
        calc_per_time = loop_count*global_work_size

        last_time_stamp = time.time()
        
        total_hashed = total_hashed + calc_per_time                            
        
        run_evt = PYCL_KERNEL[device_index](current_step, loop_count, target_diff_buf, init_img_buf, block_header_buf, output_buf).on(PYCL_QUEUE[device_index], global_work_size,lsize=local_work_items)

        output_bin, evt = buffer_to_pyarray(PYCL_QUEUE[device_index], output_buf, wait_for=run_evt, like=output_buf_arr) 

      
        

        # Wait for all events to complete
        evt.wait()
        
        nonce_bytes = output_bin.tobytes()



        if nonce_bytes[4] > 0:
            skip_hashrate_calculation = True
            
            block_header = block_header[0:76] + nonce_bytes[0:4]



            submission = (block_header+new_block[80:]).hex()
            printd(device_index,"found! submitting: {}\n".format(submission[0:160]))  
  
            
            rpc_submitblock(submission)
            LATEST_TARGET_HEIGHT = int(block_template["height"])
            
            clReleaseMemObject(target_diff_buf)
            clReleaseMemObject(init_img_buf)
            clReleaseMemObject(block_header_buf)
            clReleaseMemObject(output_buf)
            
            return

        if skip_hashrate_calculation != True:
        
            
            current_timestamp = time.time()
            diff = current_timestamp - last_time_stamp
            
            hash_rate = int(calc_per_time / diff)
            
            
            
            
            
            total_diff = current_timestamp - start_time            
            total_hash_rate = int(total_hashed / total_diff)            
            
            if MAX_HASHRATE[device_index] < hash_rate:
                MAX_HASHRATE[device_index] = hash_rate
                
            GLOBAL_STATS["hs"][DEVICEID2STATINDEX[device_index]] = hash_rate     
                
            printd(device_index,"Now: {}, Avg: {}, Max: {} hash/s (loop_count:{})".format(hash_rate,total_hash_rate,MAX_HASHRATE[device_index],loop_count))
            
             
            
            if current_step > 1 and (diff > 3  or diff < 1): 
                

                recommended_val = math.ceil((2 * loop_count) / diff)
                if recommended_val > 256:
                    recommended_val = 256
                if recommended_val < 1:
                    recommended_val = 1            
                   
                
                if CONFIG[DEVICE_ID2GROUP[device_index]]["loop_count"] == "auto":                
                    

                    if loop_count != recommended_val:
                        printd(device_index,"Fixing check interval... Setting loop_count {} to {} ...".format(loop_count,recommended_val))
                    loop_count = recommended_val
                    _loop_start_val[device_index] = recommended_val
                              
                    
                    
                
        
        
        
        if WORK_ID != current_work_id or int(block_template["height"]) <= LATEST_TARGET_HEIGHT:
            printd(device_index,"new work detected!")
            clReleaseMemObject(target_diff_buf)
            clReleaseMemObject(init_img_buf)
            clReleaseMemObject(block_header_buf)
            clReleaseMemObject(output_buf)        
            return
        current_step = current_step + 1
        
        if (current_step*global_work_size + global_work_size) > 0xFFFFFF:
            printd(device_index,"no more nonce!")
            clReleaseMemObject(target_diff_buf)
            clReleaseMemObject(init_img_buf)
            clReleaseMemObject(block_header_buf)
            clReleaseMemObject(output_buf)            
            return

            
            
            
    
            
def build_kernel(device_index):
    
    global PYCL_CTX,PYCL_QUEUE,PYCL_PROGRAM,PYCL_KERNEL,DEVICE_LIST

    try:
        cl_file = os.sep.join([os.path.dirname(os.path.abspath(__file__)),"ocv2_miner.cl"])
        printd(device_index,"Building source...")
        with open(cl_file, 'rb') as file:
            ocv2_miner_cl_source = file.read()

        bopts = bytes(CONFIG[DEVICE_ID2GROUP[device_index]]["build_flags"], 'ascii')

        PYCL_CTX[device_index] = clCreateContext(devices=[DEVICE_LIST[device_index]])
        PYCL_QUEUE[device_index] = clCreateCommandQueue(PYCL_CTX[device_index])
        PYCL_PROGRAM[device_index] = clCreateProgramWithSource(PYCL_CTX[device_index], ocv2_miner_cl_source).build(bopts)
        PYCL_KERNEL[device_index] = PYCL_PROGRAM[device_index]['search_hash']
        PYCL_KERNEL[device_index].argtypes = (cl_uint,cl_uint,cl_mem,cl_mem,cl_mem,cl_mem)
        printd(device_index,"Build complate!")

    except Exception as e:
        printd(device_index,"Build fail!")
        printd(device_index,repr(e))
        exit()

def standalone_miner(device_index):
    
    global LATEST_BLOCK_TEMPLATE,LATEST_TARGET_HEIGHT,PYCL_CTX,PYCL_QUEUE,PYCL_PROGRAM,PYCL_KERNEL

    
    
    

    while True:
        try:     
            while int(LATEST_BLOCK_TEMPLATE["height"]) <= LATEST_TARGET_HEIGHT:
                print(".", end ="")
                time.sleep(0.05)
            ocl_mine_ocvcoin(device_index)                         
            
        except Exception as e:
            printd(device_index,"exception in standalone_miner loop:")
            printd(device_index,repr(e)) 

            
            try:
                clReleaseKernel(PYCL_KERNEL[device_index])
            except Exception as e:
                pass
            try:
                clReleaseKernel(PYCL_PROGRAM[device_index])
            except Exception as e:
                pass                
            try:
                clReleaseKernel(PYCL_QUEUE[device_index])
            except Exception as e:
                pass                
            try:
                clReleaseKernel(PYCL_CTX[device_index])
            except Exception as e:
                pass                
                
                
                
                
                
            build_kernel(device_index)
            
            
            
            
            time.sleep(1)





















class MyTCPHandler(socketserver.BaseRequestHandler):
    """
    The request handler class for our server.

    It is instantiated once per connection to the server, and must
    override the handle() method to implement communication to the
    client.
    """

    def handle(self):
    
        global GLOBAL_STATS
    
        req = bytearray()
        
        i = 0
        
        while 1:
        
            i = i + 1
            buff = self.request.recv(1)
            
            if not buff:
                break
                
            req = req + buff
            
            if buff == b'\n':
                break
            
            
            if i > 300:
                return
            elif i > 100:
                time.sleep(0.01)
        
        try:
            command = req.decode(encoding="ascii",errors="ignore").strip()
            if command == "hiveos_stats": #for hiveOS
                self.request.sendall(json.dumps(GLOBAL_STATS).encode(encoding="ascii",errors="ignore") + b'\r\n') 
            elif command == "hiveos_khs": #for hiveOS
                self.request.sendall(str(int(sum(GLOBAL_STATS["hs"])/1000)).encode(encoding="ascii",errors="ignore") + b'\r\n')
                
        except Exception as e:
            pass
        

        
        






def api_server():
    

    HOST, PORT = "localhost", 30258


    while True:
        print("api server starting...")
        try:
            # Create the server, binding to HOST on port PORT
            with socketserver.TCPServer((HOST, PORT), MyTCPHandler) as server:
                # Activate the server; this will keep running until you
                # interrupt the program with Ctrl-C
                server.serve_forever()                    
        except Exception as e:
            print(repr(e))

        time.sleep(10)


        






























if __name__ == "__main__":

    screen_clear()



    argparser = argparse.ArgumentParser(prog='Ocvcoin GPU Miner',allow_abbrev=False)

    argparser.add_argument('--enable_telemetry_api', action='store_true', required=False, help="enables telemetry api server")

    argparser.add_argument('--url', required=False, help="stratum url or ocvcoin rpc url")
    argparser.add_argument('--template', required=False, help="wallet and worker template")
    argparser.add_argument('--pass', required=False, help="stratum password")


    PRGARGS, unknown_args = argparser.parse_known_args()



    OCVCOIN_ADDR_TAKEN_FROM_ARG = None
    OCVCOIN_WORKERNAME_TAKEN_FROM_ARG = ""
    
    
    if len(sys.argv) > 1:
    
        if PRGARGS.template != None:
            OCVCOIN_ADDR_TAKEN_FROM_ARG = PRGARGS.template
        else:   
            OCVCOIN_ADDR_TAKEN_FROM_ARG = sys.argv[1].strip()

        OCVCOIN_ADDR_TAKEN_FROM_ARG = OCVCOIN_ADDR_TAKEN_FROM_ARG.strip("_")

        OCVCOIN_ADDR_TAKEN_FROM_ARG = OCVCOIN_ADDR_TAKEN_FROM_ARG.strip()

        _splt = OCVCOIN_ADDR_TAKEN_FROM_ARG.split(".",1)
        
        OCVCOIN_ADDR_TAKEN_FROM_ARG = _splt[0].strip()
        
        if len(_splt) == 2:
            OCVCOIN_WORKERNAME_TAKEN_FROM_ARG = _splt[1].strip()
        
        print("\nAddress taken from arguments: "+OCVCOIN_ADDR_TAKEN_FROM_ARG)
        
        if check_addr(OCVCOIN_ADDR_TAKEN_FROM_ARG) != True:
            OCVCOIN_ADDR_TAKEN_FROM_ARG = None
            if sys.__stdin__.isatty():
                print("Invalid ocvcoin address! Ignoring...")
            else:
                print("\n\nInvalid ocvcoin address!")
                
                if OCVCOIN_ADDR_TAKEN_FROM_ARG == "ADD_YOUR_OCVCOIN_ADDRESS_HERE":
                    print("You forgot to change the ___ADD_YOUR_OCVCOIN_ADDRESS_HERE___ in the command!")
                else:
                    print("Please make sure your ocvcoin address at the end of the command is correct!\n\n")
                exit()


    else:
        if not sys.__stdin__.isatty():
            print("\n\nPlease leave a space at the end of the command and add your ocvcoin address!\n\n")
            exit()


    if PRGARGS.url != None:
        PARSED_URL = urllib.parse.urlparse(PRGARGS.url)
    else:
        PARSED_URL = urllib.parse.urlparse("")


    IS_NEW_VERSION_AVAILABLE = False
    try:           
        request = urllib.request.Request("https://raw.githubusercontent.com/ocvcoin/gpuminer/main/version.txt")
        sslfix_context = ssl._create_unverified_context()        
        f = urllib.request.urlopen(request,context=sslfix_context,timeout=5)
        resp = f.read()
        if resp.decode('ascii').strip() != CURRENT_MINER_VERSION:
            print("")
            print("\033[91m\nNew version is available!\nTo update, visit: ocvcoin.com\n\033[00m")
            IS_NEW_VERSION_AVAILABLE = True
    except Exception as e:
        print("\nNew version check failed! Skipping...\n")






    print("Ocvcoin Gpu Miner v"+str(CURRENT_MINER_VERSION)+" starting...")
    print(platform.uname())




    if os.name == 'nt':   
        config_location_path = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop')         
    elif os.name == 'posix':    
        config_location_path = os.path.join(os.path.join(os.path.expanduser('~')), 'Desktop') 

        if not os.path.exists(config_location_path) or not os.path.isdir(config_location_path):
            config_location_path = os.path.join(os.path.expanduser('~'))


    config_file = os.sep.join([config_location_path,"Ocvcoin_Gpu_Miner.ini"])


    CONFIG = configparser.ConfigParser()


    CONFIG.read(config_file) 
    
    print("Using %s" % _dll_filename)

    try:
        

        BUF_SIZE = 65536  # lets read stuff in 64kb chunks!


        sha256 = hashlib.sha256()

        with open(_dll_filename, 'rb') as f:
            while True:
                data = f.read(BUF_SIZE)
                if not data:
                    break
   
                sha256.update(data)
        
 
        print("SHA256: {0}".format(sha256.hexdigest()))

        
    except Exception as e:
        pass

    
    
    print("Python: "+sys.version)

    
    print("\nSettings file: %s\n" % config_file)



    try:
        platforms = clGetPlatformIDs()
    except Exception as e: 
        print("Error!")
        print(repr(e))
        print("Make sure the GPU drivers are installed!")
        print("This could be the cause of this error")
        
        exit()

    if len(platforms) < 1:
        print("No platforms supporting OpenCL were found!")
        print("Make sure the GPU drivers are installed!")
        print("This could be the cause of this error")
        exit()

    default_configs = {}
  
    
    device_groups = {}
    DEVICE_LIST = {}
    DEVICE_NAMES = {}
    DEVICE_BUS_LIST = {}
    i = 0
    
    
    device_search_errors = []
    
    
    device_speeds = {}
    
    
    for p in platforms:
        try:
            for d in clGetDeviceIDs(p,device_type = cl_device_type.CL_DEVICE_TYPE_GPU):
                
                
                

                try:
                    max_compute_units = str(clGetDeviceInfo(d, cl_device_info.CL_DEVICE_MAX_COMPUTE_UNITS))
                except Exception as e:             
                    max_compute_units = str(type(e).__name__)

                try:
                    max_clock_freq = str(clGetDeviceInfo(d, cl_device_info.CL_DEVICE_MAX_CLOCK_FREQUENCY))
                except Exception as e:             
                    max_clock_freq = str(type(e).__name__)











                device_bus = ""

                try:
                    device_bus = str(clGetDeviceInfo(d, cl_device_info.CL_DEVICE_PCI_BUS_INFO_KHR)[1])
                except Exception as e:
                    try:
                        device_bus = str(type(e).__name__[1])
                    except Exception as e:
                        pass

                if not re.match(re.compile('^\d+$', re.UNICODE), device_bus):                
                    try:
                        device_bus = str(clGetDeviceInfo(d, cl_device_info.CL_DEVICE_PCI_BUS_ID_NV))
                    except Exception as e:
                        try:
                            device_bus = str(type(e).__name__)
                        except Exception as e:
                            pass                


                if not re.match(re.compile('^\d+$', re.UNICODE), device_bus):                
                    try:
                        device_bus = str(clGetDeviceInfo(d, cl_device_info.CL_DEVICE_PCIE_ID_AMD))
                    except Exception as e:
                        try:
                            device_bus = str(type(e).__name__)
                        except Exception as e:
                            pass 





                DEVICE_BUS_LIST[i] = device_bus





                

                device_group_name = str(d.name) + " " + str(d.profile) + " " + max_compute_units + " " + max_clock_freq
                
                
                device_group_name = re.sub(re.compile('\s+', re.UNICODE), ' ', device_group_name).strip()
                
                device_speeds[device_group_name] = (int(max_compute_units)*int(max_clock_freq))
                
                if device_group_name not in device_groups:
                    device_groups[device_group_name] = []
                
                device_groups[device_group_name].append(i)
                
                

                device_full_name = "D"+str(len(device_groups[device_group_name]) - 1)+": "+ str(d.name) + " " + str(d.profile) + " " + max_compute_units + " " + max_clock_freq
                device_full_name = re.sub(re.compile('\s+', re.UNICODE), ' ', device_full_name).strip()                
                
                
                
                DEVICE_LIST[i] = d
                DEVICE_NAMES[i] = device_full_name


                



                default_configs[device_group_name] = {}
                default_configs[device_group_name]["build_flags"] = "-cl-fast-relaxed-math -cl-mad-enable -cl-no-signed-zeros"
                
                
                
                number_of_global_work_items = ((int(max_compute_units)*5120*2) / 40)
                if number_of_global_work_items % 256 != 0:
                    number_of_global_work_items = (int(number_of_global_work_items / 256) + 1) * 256
                
                
                default_configs[device_group_name]["number_of_global_work_items"] = str(int(number_of_global_work_items))
                default_configs[device_group_name]["number_of_local_work_items"] = "256"
                
                default_configs[device_group_name]["loop_count"] = "auto"
                
                default_configs[device_group_name]["reward_addr"] = ""
                
                
                i = i + 1
        except Exception as e:
            device_search_errors.append(repr(e))
    
    if len(device_groups) < 1:
        print("No devices supporting OpenCL were found!")
        print("Make sure the GPU drivers are installed!")
        print("This could be the cause of this error")
        print(device_search_errors)
        exit()

    DEVICE_ID2GROUP = {}

    new_group = {}
    for device_group_name in device_groups:
    
    
        new_key = str(len(device_groups[device_group_name]))+"x"+ device_group_name
        new_group[new_key] = device_groups[device_group_name]
        device_speeds[new_key] = device_speeds[device_group_name]
        del device_speeds[device_group_name] 

        
        if new_key not in CONFIG:
            CONFIG[new_key] = default_configs[device_group_name]
        
        for device_index in device_groups[device_group_name]:
            DEVICE_NAMES[device_index] = DEVICE_NAMES[device_index].replace(device_group_name, new_key)
            DEVICE_ID2GROUP[device_index] = new_key
    device_groups = new_group
    del new_group
    del default_configs

    print("Device Group Selection")
    print("Please enter group number:")  
    i = 1
    for device_group_name in device_groups:
        print(str(i) + " - " + device_group_name)
        i = i + 1
    print(str(i) + " - ALL")    
    
    if sys.__stdin__.isatty():
        selected_group_number = input().strip()
    else:
        selected_group_number = str(i)
            
    if selected_group_number.isnumeric() == False or int(selected_group_number) < 1 or int(selected_group_number) > (len(device_groups)+1):
        print("Invalid group number!")
        exit()        
    
    if int(selected_group_number) == (len(device_groups)+1):
        selected_group_name = "ALL"
    else:
        i = 1
        for device_group_name in device_groups:
            if int(selected_group_number) == i:
                selected_group_name = device_group_name
                break
            i = i + 1
    

  

    for device_group_name in device_groups:
    
        if selected_group_name == "ALL" or selected_group_name == device_group_name:
        
            if OCVCOIN_ADDR_TAKEN_FROM_ARG != None:
                addr = OCVCOIN_ADDR_TAKEN_FROM_ARG
            else:
                if check_addr(CONFIG[device_group_name]["reward_addr"]):
                    addr = CONFIG[device_group_name]["reward_addr"]
                    
                else: 
                    
                    print("Requiring a reward address for "+device_group_name)
                    print("\nYou can try wallet.ocvcoin.com to create a wallet and get an address!")
                    addr = input("\nEnter your ocvcoin address:\n(you can right click & paste it)\n ")
                    addr = addr.strip()


                    if check_addr(addr) != True:
                        print("Wrong address. Address must be of bech32 type!")
                        print("(It should start with ocv1)")
                        exit()

            CONFIG[device_group_name]["reward_addr"] = addr        
            if "uniq_id" not in CONFIG[device_group_name]:
                CONFIG[device_group_name]["uniq_id"] = hashlib.sha256(secrets.token_bytes(256)+EXTRA_SEED+device_group_name.encode(encoding="ascii",errors="ignore")).hexdigest()[:16]



    if "WORKER" not in CONFIG:
        CONFIG["WORKER"] = {}

    if "worker_name" not in CONFIG["WORKER"]:
        CONFIG["WORKER"]["worker_name"] = OCVCOIN_WORKERNAME_TAKEN_FROM_ARG
    elif OCVCOIN_WORKERNAME_TAKEN_FROM_ARG != "":
        CONFIG["WORKER"]["worker_name"] = OCVCOIN_WORKERNAME_TAKEN_FROM_ARG

    try:

        with open(config_file, 'w') as configfile_descp:
          CONFIG.write(configfile_descp)

    except Exception as e:
        print("Warning!")
        print("Failed to save settings to "+str(config_file))
        print(repr(e))


    for device_group_name in device_groups:
    
        if selected_group_name == "ALL" or selected_group_name == device_group_name:
            print("\n     "+device_group_name)
            for k in CONFIG[device_group_name]:
                print("          " + k + " = " + CONFIG[device_group_name][k])
            print("")
    






    PYCL_CTX = {}
    PYCL_QUEUE = {}
    PYCL_PROGRAM = {}
    PYCL_KERNEL = {}    
    threads_list = []






    GLOBAL_STATS = {}
    DEVICEID2STATINDEX = {}

    if PRGARGS.enable_telemetry_api:
        threads_list.append(Thread(target=api_server, args=[],daemon=True))


    print("Mining Method Selection")
    print("Please enter a method number:")

    mining_methods_list = ["POOL","POOL (SSL CONNECTION)","SOLO POOL","SOLO POOL (SSL CONNECTION)","SOLO (WITH OUR PUBLIC RPC)"]
    
    i = 0
    for mining_method in mining_methods_list:
        print(str(i+1) + " - " + mining_method)
        i = i + 1
        
    if PARSED_URL.scheme == "http" or PARSED_URL.scheme == "https":
        RPC_SERVERS.append([PRGARGS.url,"",""])
        selected_mining_method = 5
    else:    
        
        HOSTPORT_ARR = PARSED_URL.netloc.lower().split(":",1)
        
        if (PARSED_URL.scheme == "stratum+tcp" or PARSED_URL.scheme == "stratum+tcps") and len(HOSTPORT_ARR) == 2 and re.match(re.compile('^\d+$'),HOSTPORT_ARR[1]) and re.match(re.compile('^[a-z0-9-\.]+$'),HOSTPORT_ARR[0]):
        
            if HOSTPORT_ARR[0] == "pool.auto.select" or HOSTPORT_ARR[0] == "mining4people.auto.select" or HOSTPORT_ARR[0] == "phalanxmine.auto.select":
                if PARSED_URL.scheme == "stratum+tcps":
                    selected_mining_method = 2
                else:
                    selected_mining_method = 1
            elif HOSTPORT_ARR[0] == "solo-pool.auto.select" or HOSTPORT_ARR[0] == "solo-mining4people.auto.select" or HOSTPORT_ARR[0] == "solo-phalanxmine.auto.select":        
                if PARSED_URL.scheme == "stratum+tcps":
                    selected_mining_method = 4
                else:
                    selected_mining_method = 3                
            else:    
                selected_mining_method = 0
                
        else:    
            
            if sys.__stdin__.isatty():    
                selected_mining_method = int(input().strip())
            else:
                selected_mining_method = 2
            
            
            if selected_mining_method > len(mining_methods_list) or selected_mining_method < 1:
                print("invalid method number!")
                exit()
        
    
    if selected_mining_method < 5:
    
        plst = []

        if len(HOSTPORT_ARR) != 2 or "phalanxmine" not in HOSTPORT_ARR[0]:
            #POOL NAME,HOSTNAME,PPLNS PORT,SOLO PORT,PPLNS SSL PORT,SOLO SSL PORT,PING
            plst.append(["Mining4People.com Australia"   ,"au.mining4people.com" ,3376,3379,23376,23379,0 ])
            plst.append(["Mining4People.com Brazil"      ,"br.mining4people.com" ,3376,3379,23376,23379,0 ])
            plst.append(["Mining4People.com Germany"     ,"de.mining4people.com" ,3376,3379,23376,23379,0 ])
            plst.append(["Mining4People.com Canada"      ,"na.mining4people.com" ,3376,3379,23376,23379,0 ])
            plst.append(["Mining4People.com Finland"     ,"fi.mining4people.com" ,3376,3379,23376,23379,0 ])
            plst.append(["Mining4People.com India"       ,"in.mining4people.com" ,3376,3379,23376,23379,0 ])

        if len(HOSTPORT_ARR) != 2 or "mining4people" not in HOSTPORT_ARR[0]:
            plst.append(["pool.PhalanxMine.com Sweden",	      "se-stratum.phalanxmine.com" ,5120,5120,25120,25120,0 ])	
            plst.append(["pool.PhalanxMine.com Singapore", 	  "sg-stratum.phalanxmine.com" ,5120,5120,25120,25120,0 ])	
            plst.append(["pool.PhalanxMine.com United States","us-stratum.phalanxmine.com" ,5120,5120,25120,25120,0 ])	
            plst.append(["pool.PhalanxMine.com Australia",	  "aus-stratum.phalanxmine.com",5120,5120,25120,25120,0 ])	
            plst.append(["pool.PhalanxMine.com Russia",	      "ru-stratum.phalanxmine.com" ,5120,5120,25120,25120,0 ])	
            plst.append(["pool.PhalanxMine.com Brazil", 	  "br-stratum.phalanxmine.com" ,5120,5120,25120,25120,0 ])	
            plst.append(["pool.PhalanxMine.com Germany",	  "de-stratum.phalanxmine.com" ,5120,5120,25120,25120,0 ])	
            plst.append(["pool.PhalanxMine.com Japan", 	      "jp-stratum.phalanxmine.com" ,5120,5120,25120,25120,0 ])
        
        
        STRATUM_GLOBALS = {}
        
        
        if selected_mining_method == 1:
           
            stratum_port_index = 2
            STRATUM_GLOBALS["ssl"] = False
            
        elif selected_mining_method == 2:
            
            stratum_port_index = 4
            STRATUM_GLOBALS["ssl"] = True
            
        elif selected_mining_method == 3:
            
            stratum_port_index = 3  
            STRATUM_GLOBALS["ssl"] = False
            
        elif selected_mining_method == 4:
            
            stratum_port_index = 5
            STRATUM_GLOBALS["ssl"] = True

        if selected_mining_method != 0:
        
            print("pinging servers...")
            ping_threads_list = []
            STRATUM_SERVER_PINGS = {}
            i = 0
            for _pool in plst:           

                ping_threads_list.append(Thread(target=stratum_timed_check, args=[i,_pool[1],_pool[stratum_port_index],1,STRATUM_GLOBALS["ssl"]],daemon=True))
                
                i = i + 1
                
            # Start all threads
            for th in ping_threads_list:
                th.start()
                
            
            # Wait for all of them to finish
            for th in ping_threads_list:
                th.join() 
            
            sorted_plst_list = []
            
            sorted_stratum_servers = sorted(STRATUM_SERVER_PINGS.items(), key=operator.itemgetter(1))
            
            for _sorted in sorted_stratum_servers:
                if _sorted[1] > 0:
                    plst[_sorted[0]][6] = _sorted[1]
                    sorted_plst_list.append(plst[_sorted[0]])
            if len(sorted_plst_list) > 0:
                plst = sorted_plst_list

            print("Pool Selection")
            print("Please enter a pool number:")

            
            
            i = 0
            print(f"{'' : <3}   {'' : <34}   {'ping' : <5}")
            for pl in plst:
            
                pl_ping = "{:.3f}".format(pl[6])
                print(f"{str(i+1) : <3} - {pl[0] : <34} - {pl_ping : <5}")
                
                i = i + 1
                
            if sys.__stdin__.isatty():
                selected_pool = int(input().strip())
            else:
                selected_pool = 1
            
            if selected_pool > len(plst) or selected_pool < 1:
                print("invalid pool number!")
                exit()
            
            
        
        STRATUM_GLOBALS["id2method"] = {}
        STRATUM_GLOBALS["err"] = {}
        STRATUM_GLOBALS["fail_count"] = {}
        STRATUM_GLOBALS["success_count"] = {}
         
        if selected_mining_method != 0:
        
            STRATUM_GLOBALS["host"] = plst[selected_pool-1][1]
            STRATUM_GLOBALS["port"] = plst[selected_pool-1][stratum_port_index]
        
        if selected_mining_method == 0:
            STRATUM_GLOBALS["host"] = HOSTPORT_ARR[0]
            STRATUM_GLOBALS["port"] = int(HOSTPORT_ARR[1])        
            STRATUM_GLOBALS["pass"] = ""
            
            STRATUM_GLOBALS["ssl"] = (PARSED_URL.scheme == "stratum+tcps")
        
        elif selected_mining_method == 1:
            STRATUM_GLOBALS["pass"] = "x"            
            
            
        elif selected_mining_method == 2:
            STRATUM_GLOBALS["pass"] = "x"
            
            
        elif selected_mining_method == 3:
            STRATUM_GLOBALS["pass"] = "x,m=solo"
            
            
        elif selected_mining_method == 4:
            STRATUM_GLOBALS["pass"] = "x,m=solo"
            




        print("     SSL: {}".format(STRATUM_GLOBALS["ssl"]))
        print("     HOST: {}".format(STRATUM_GLOBALS["host"]))
        print("     PORT: {}".format(STRATUM_GLOBALS["port"])) 

        pass_attr = getattr(PRGARGS, 'pass')
        if pass_attr != None and pass_attr != "":  
            print("     PASS: {}".format(pass_attr))
        else:    
            print("     PASS: {}".format(STRATUM_GLOBALS["pass"]))

        
        







        if CONFIG["WORKER"]["worker_name"] == "":
        
            print("\nWorker Name Selection")
            print("Please enter a worker name:")            
    
            if sys.__stdin__.isatty():

            
                CONFIG["WORKER"]["worker_name"] = input().strip()
            

                try:

                    with open(config_file, 'w') as configfile_descp:
                      CONFIG.write(configfile_descp)

                except Exception as e:
                    pass








        

        



        STRATUM_GLOBALS["log_lock"] = threading.Lock()
        STRATUM_GLOBALS["last_rpc_id"] = 0
        STRATUM_GLOBALS["rpc_id_lock"] = threading.Lock()
          
        STRATUM_CONNECTIONS = {}


        for device_group_name in device_groups:

            if selected_group_name == "ALL" or selected_group_name == device_group_name:
                
            
                STRATUM_CONNECTIONS[device_group_name] = {}

                STRATUM_CONNECTIONS[device_group_name]["work_id"] = 0

                STRATUM_CONNECTIONS[device_group_name]["last_extranonce2"] = 0
                        
                
                
                STRATUM_CONNECTIONS[device_group_name]["sendall_lock"] = threading.Lock()
                STRATUM_CONNECTIONS[device_group_name]["connect_lock"] = threading.Lock()		
                STRATUM_CONNECTIONS[device_group_name]["extranonce2_lock"] = threading.Lock()
                




                STRATUM_CONNECTIONS[device_group_name]["subscribe"] = None
                STRATUM_CONNECTIONS[device_group_name]["notify"] = None
                STRATUM_CONNECTIONS[device_group_name]["target"] = None		
                
                
                #0.01 is best for rtx 4090;  
                STRATUM_CONNECTIONS[device_group_name]["set_diff"] = float((device_speeds[device_group_name] * 0.01) / (128*2595))
                
                
                                
            
            
                STRATUM_CONNECTIONS[device_group_name]["worker_name"] = re.sub('[^0-9a-zA-Z]+', '_', CONFIG["WORKER"]["worker_name"]+"_"+device_group_name.replace("FULL_PROFILE", "FP").replace("EMBEDDED_PROFILE", "EP")+"_"+CONFIG[device_group_name]["uniq_id"])
                
                
                
                                
                
                
                
                
                
                
                STRATUM_CONNECTIONS[device_group_name]["worker_name"] = re.sub('[_]+', '_', STRATUM_CONNECTIONS[device_group_name]["worker_name"]).strip("_")
                
                
                print("Worker: "+STRATUM_CONNECTIONS[device_group_name]["worker_name"])
                print("Suggested diff: {:.6f}".format(STRATUM_CONNECTIONS[device_group_name]["set_diff"]))
                
                STRATUM_CONNECTIONS[device_group_name]["worker_name"] = CONFIG[device_group_name]["reward_addr"]+"."+STRATUM_CONNECTIONS[device_group_name]["worker_name"]
                stratum_reconnect(device_group_name)
                
               
                
                



                
                







                    
                    
                    
                    
                    
                    
                    
        i = 0

        for device_group_name in device_groups:

            if selected_group_name == "ALL" or selected_group_name == device_group_name:
                
                threads_list.append(Thread(target=stratum_listen_lines, args=[device_group_name],daemon=True))
                
                for device_index in device_groups[device_group_name]:  
                    build_kernel(device_index)            
                    threads_list.append(Thread(target=stratum_miner, args=[device_index],daemon=True))
                    DEVICEID2STATINDEX[device_index] = i
                    i = i + 1
                    
                    
                    
        threads_list.append(Thread(target=stratum_print_stats, args=[],daemon=True))            


        
        threads_list.append(Thread(target=stratum_print_url, args=[],daemon=True))












    else:

        try:

            ocvcoin_folder = False
            ocvcoin_configdata = False
            if os.name == 'nt':    
                ocvcoin_folder = os.sep.join([os.getenv('APPDATA'),"Ocvcoin"])      
            elif os.name == 'posix':
                ocvcoin_folder = os.path.expanduser(os.sep.join(["~",".ocvcoin"]))

            if ocvcoin_folder != False and os.path.isdir(ocvcoin_folder):
                
                ocvcoin_configfile = os.sep.join([ocvcoin_folder,"ocvcoin.conf"])
                if os.path.isfile(ocvcoin_configfile):
                    f = open(ocvcoin_configfile, "r")
                    ocvcoin_configdata = f.read()
                    f.close()
                    
                    check_rpc_config = re.search(rpc_check_regexp,ocvcoin_configdata)
                    if not check_rpc_config:
                        f = open(ocvcoin_configfile, "w")
                        ocvcoin_configdata = rpc_config+"\r\n\r\n\r\n\r\n"+ocvcoin_configdata
                        f.write(ocvcoin_configdata)
                        f.close()
                        print(ocvcoin_core_restart_warning)
                        
                    
                elif not os.path.exists(ocvcoin_configfile):
                    f = open(ocvcoin_configfile, "w")
                    ocvcoin_configdata = rpc_config+"\r\n\r\n\r\n\r\n"
                    f.write(ocvcoin_configdata)
                    f.close()
                    print(ocvcoin_core_restart_warning)
                    

            if ocvcoin_configdata != False:
                check_rpc_config = re.search(rpc_check_regexp,ocvcoin_configdata)
                if check_rpc_config:
                    print("We have detected that you have Ocvcoin Core installed on your system.")
                    print("While mining, it is recommended to keep Ocvcoin Core running!")
                    RPC_SERVERS.append(["http://127.0.0.1:8332","ocvcoinrpc",check_rpc_config.group(1)])

        except Exception as e:
            print("Ocvcoin Core Configurator Failed")
            print(repr(e))




        check_latest_block()



        
        i = 0
        
        for device_group_name in device_groups:
        
            if selected_group_name == "ALL" or selected_group_name == device_group_name:
                
                for device_index in device_groups[device_group_name]:            
                    build_kernel(device_index)
                    threads_list.append(Thread(target=standalone_miner, args=[device_index],daemon=True))


                    DEVICEID2STATINDEX[device_index] = i
                    i = i + 1
                    



    GLOBAL_STATS["hs"] = []
    GLOBAL_STATS["hs_units"] = "hs"
    #GLOBAL_STATS["temp"] = []
    #GLOBAL_STATS["fan"] = []
    GLOBAL_STATS["uptime"] = int(time.time())
    GLOBAL_STATS["ver"] = CURRENT_MINER_VERSION
    GLOBAL_STATS["ar"] = [0,0]
    GLOBAL_STATS["algo"] = "ocv2"
    GLOBAL_STATS["bus_numbers"] = []    
    
    
    for _key in DEVICEID2STATINDEX:
        GLOBAL_STATS["hs"].append(0)
        #GLOBAL_STATS["temp"].append(0)
        #GLOBAL_STATS["fan"].append(0)
        GLOBAL_STATS["bus_numbers"].append(0)
        
    for _key in DEVICEID2STATINDEX:
        GLOBAL_STATS["bus_numbers"][DEVICEID2STATINDEX[_key]] = DEVICE_BUS_LIST[_key]





    # Start all threads
    for th in threads_list:
        th.start()
        
    
    # Wait for all of them to finish
    for th in threads_list:
        th.join()