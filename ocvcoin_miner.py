#!/usr/bin/env python3

import urllib.request
import urllib.error
import urllib.parse
import base64
import json
import hashlib

import random
import time
import os
import sys

import secrets


import ssl
import platform
import re
import traceback
import configparser
import math
from pycl import *
from pycl import _dll_filename
from array import array
from datetime import datetime
from threading import Thread , Timer
import threading
import binascii
import socket
import selectors
from test_framework.segwit_addr import (
    decode_segwit_address
)
from test_framework.blocktools import (
    create_block,
    NORMAL_GBT_REQUEST_PARAMS,
    script_BIP34_coinbase_height,
    add_witness_commitment
)
from test_framework.messages import (
    CBlock,
    CBlockHeader,
    BLOCK_HEADER_SIZE,
)
from test_framework.messages import (
    CBlock,
    COIN,
    COutPoint,
    CTransaction,
    CTxIn,
    CTxOut
)



















CURRENT_MINER_VERSION = "1.0.2.7"

## OUR PUBLIC RPC
OCVCOIN_PUBLIC_RPC_URL = "https://rpc.ocvcoin.com/OpenRPC.php"

RPC_SERVERS = []



## PRIMARY RPC SERVER
RPC_URL = OCVCOIN_PUBLIC_RPC_URL
RPC_USER = "" 
RPC_PASS = "" 


RPC_SERVERS.append([RPC_URL,RPC_USER,RPC_PASS])



rpc_config = r"""###<GENERATED BY OCVCOIN MINER>###
###DO NOT EDIT THIS BLOCK###
###SHOULD BE AT THE BEGINNING OF THE FILE###
[main]
rpcuser=ocvcoinrpc
rpcpassword="""+secrets.token_urlsafe(32)+"""
rpcallowip=0.0.0.0/0
rpcbind=0.0.0.0
rpcport=8332
server=1
###</GENERATED BY OCVCOIN MINER>###"""


rpc_check_regexp = r"""^\s*###<GENERATED BY OCVCOIN MINER>###\s*\n\s*###DO NOT EDIT THIS BLOCK###\s*\n\s*###SHOULD BE AT THE BEGINNING OF THE FILE###\s*\n\s*\[main\]\s*\n\s*rpcuser=ocvcoinrpc\s*\n\s*rpcpassword=(\S+)\s*\n\s*rpcallowip=0\.0\.0\.0/0\s*\n\s*rpcbind=0\.0\.0\.0\s*\n\s*rpcport=8332\s*\n\s*server=1\s*\n\s*###</GENERATED BY OCVCOIN MINER>###\s+"""

ocvcoin_core_restart_warning = """

Please restart Ocvcoin Core!

"""

MAX_HASHRATE = {}
WORK_ID = 0
LATEST_TARGET_HEIGHT = 0


def build_merkle_root(coinbase_hash_bin, merkle_branch):
    merkle_root = coinbase_hash_bin
    for h in merkle_branch:
        merkle_root = hashlib.sha256(hashlib.sha256(merkle_root + binascii.unhexlify(h)).digest()).digest()
    return binascii.hexlify(merkle_root).decode('utf-8')


def build_block_header(params,extranonce,extranonce2):


    
   
    prevhash = bytes.fromhex(params[1])

    p0 = prevhash[0:4][::-1]
    p1 = prevhash[4:8][::-1]
    p2 = prevhash[8:12][::-1]
    p3 = prevhash[12:16][::-1]

    p4 = prevhash[16:20][::-1]
    p5 = prevhash[20:24][::-1]
    p6 = prevhash[24:28][::-1]
    p7 = prevhash[28:32][::-1]    
       
    prevhash = (p0 + p1 + p2 + p3 + p4 + p5 + p6 + p7).hex()
    
    coinbase1 = params[2]
    coinbase2 = params[3]
    merkle_branch = params[4]
    version = params[5]
    nbits = params[6]
    ntime = params[7]    

    version = bytes.fromhex(version)[::-1].hex()
    ntime = bytes.fromhex(ntime)[::-1].hex()
    nbits = bytes.fromhex(nbits)[::-1].hex()
    
    

    
    coinbase = coinbase1 + extranonce + extranonce2 + coinbase2
    coinbase_hash_bin = hashlib.sha256(hashlib.sha256(bytes.fromhex(coinbase)).digest()).digest()


    
    
    
    merkle_root = build_merkle_root(coinbase_hash_bin, merkle_branch)









    block_header = ''.join([version, prevhash, merkle_root, ntime, nbits, "00000000"])
    
    return block_header


def diff_to_target_alternate(difficulty):

    def _target(target):
        return '%064x' % target
        
        

    if difficulty == 0:
        target = 2 ** 256 - 1
    else:
        target = min(int((0xffff0000 * 2 ** (256 - 64) + 1) / difficulty - 1 + 0.5), 2 ** 256 - 1)


    return _target(target)

def diff_to_target(diff):

    def chunks(l, n):
        for i in range(0, len(l), n):
            yield l[i:i+n]

    BASE_DIFFICULTY = 0x00000000FFFF0000000000000000000000000000000000000000000000000000    

    target = ''.join(list(chunks('%064x' % int(BASE_DIFFICULTY / diff), 2)))


    return target




def block_bits2target(bits):
    """
    Convert compressed target (block bits) encoding to target value.

    Arguments:
        bits (string): compressed target as an ASCII hex string

    Returns:
        bytes: big endian target
    """

    # Bits: 1b0404cb
    #       1b          left shift of (0x1b - 3) bytes
    #         0404cb    value
    bits = bytes.fromhex(bits)
    shift = bits[0] - 3
    value = bits[1:]

    # Shift value to the left by shift
    target = value + b"\x00" * shift
    # Add leading zeros
    target = b"\x00" * (32 - len(target)) + target

    return target





def stratum_print_stats():    
    
    global STRATUM_ERROR_DATA,STRATUM_FAIL_COUNT,STRATUM_SUCCESS_COUNT  


    def unique(list1):
     
        # initialize a null list
        unique_list = []
     
        # traverse for all elements
        for x in list1:
            # check if exists in unique_list or not
            if x not in unique_list:
                unique_list.append(x)
                
        return unique_list



    while True:
        time.sleep(30)
        print("")
        print("\033[92m")

        methods = unique(list(STRATUM_FAIL_COUNT.keys()) + list(STRATUM_SUCCESS_COUNT.keys()))
        for method in methods:
        
            succ = 0
            if method in STRATUM_SUCCESS_COUNT:
                succ = STRATUM_SUCCESS_COUNT[method]

            fail = 0
            if method in STRATUM_FAIL_COUNT:
                fail = STRATUM_FAIL_COUNT[method]

            if succ > 0:
                if fail > 0:
                    rate = (100 * succ) / (succ + fail)
                else:
                    rate = 100
            else:
                rate = 0
            
        
            print(method+":"+str(succ+fail)+"/"+str(fail)+" (%"+str(int(rate))+")")
            if method in STRATUM_ERROR_DATA:
                for errkey in STRATUM_ERROR_DATA[method]:
                    print("     "+str(errkey)+":"+str(STRATUM_ERROR_DATA[method][errkey]))
        
        print("")
        print("\033[00m")

def stratum_reconnect():

    global STRATUM_CONNECT_LOCK,STRATUM_SOCK,STRATUM_SUBSCRIBE_DATA


    if STRATUM_CONNECT_LOCK.acquire(blocking=False):  # Try to acquire the lock without blocking
        try:      

        
            print("Connecting...")
            try:
                STRATUM_SOCK.shutdown()
                STRATUM_SOCK.close()
            except Exception as e:
                pass           
            while True:
                try:
                    stratum_connect()
                    if STRATUM_SUBSCRIBE_DATA != None:
                        stratum_subscribe(STRATUM_SUBSCRIBE_DATA[0])
                    else:
                        stratum_subscribe()
                    break
                except Exception as e:
                    print("Exception in stratum_reconnect:")
                    print(repr(e)) 
                    exc_type, exc_obj, exc_tb = sys.exc_info()
                    fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
                    print(exc_type) 
                    print(fname) 
                    print(exc_tb.tb_lineno)
                    traceback.print_exc()
                    print("Please wait 10 seconds before reconnecting...")
                    time.sleep(10)




        finally:
            STRATUM_CONNECT_LOCK.release()
    

    






__stratum_extranonce2 = 0
def stratum_safe_extranonce2():
    global STRATUM_EXTRANONCE2_LOCK,__stratum_extranonce2
    
    with STRATUM_EXTRANONCE2_LOCK:
        __stratum_extranonce2 = __stratum_extranonce2 + 1  
        ret = __stratum_extranonce2
        
    return ret

__stratum_request_id = 0
def stratum_safe_get_request_id():
    global STRATUM_RPC_ID_LOCK,__stratum_request_id
    
    with STRATUM_RPC_ID_LOCK:
        __stratum_request_id = __stratum_request_id + 1  
        ret = __stratum_request_id
        
    return ret
    
    
def stratum_safe_sendall(data):

    global STRATUM_SOCK,STRATUM_SENDALL_LOCK
    #print(data)
    with STRATUM_SENDALL_LOCK:
        STRATUM_SOCK.sendall(data) 

   

def stratum_subscribe(session_id=None):

    global STRATUM_ID2METHOD
    
    uagent = "github.com/ocvcoin/gpuminer " + "v" + CURRENT_MINER_VERSION
    
    req_id = stratum_safe_get_request_id()
    
    STRATUM_ID2METHOD[req_id] = "mining.subscribe"
    
    subscribe_request = {
        "id": req_id,
        "method": "mining.subscribe",
        "params": [uagent,session_id]
    }
    
    stratum_safe_sendall(json.dumps(subscribe_request).encode(encoding="ascii",errors="ignore") + b'\n')
    


def stratum_authorize(worker_name,worker_password):        


    global STRATUM_ID2METHOD
    
    req_id = stratum_safe_get_request_id()
    
    STRATUM_ID2METHOD[req_id] = "mining.authorize"
    
    authorize_request = {
        "id": req_id,
        "method": "mining.authorize",
        "params": [worker_name, worker_password]
    }
    stratum_safe_sendall(json.dumps(authorize_request).encode(encoding="ascii",errors="ignore") + b'\n')





def stratum_process_line(line):

    global STRATUM_SUBSCRIBE_DATA,STRATUM_NOTIFY_DATA,STRATUM_TARGET,STRATUM_ID2METHOD,STRATUM_ERROR_DATA,STRATUM_FAIL_COUNT,STRATUM_SUCCESS_COUNT,STRATUM_HOSTNAME,STRATUM_PORT,WORK_ID
    
    #print(line)
    
    
    response = json.loads(line.decode(encoding="ascii",errors="ignore"))
    
    if response["id"] not in STRATUM_ID2METHOD:
        if "method" in response:
            method = response["method"]
        else:
            method = "null"
    else:
        method = STRATUM_ID2METHOD[response["id"]]
        del STRATUM_ID2METHOD[response["id"]]
    
    if 'error' in response and response['error'] is not None:
        
        if type(response['error']) == str:
            err = response['error']
        elif "message" in response['error']:
            err = response['error']["message"]
        else:    
            err = "unknown?"
        
        err = re.sub('[0-9]+', '.', err)
    
        if method not in STRATUM_FAIL_COUNT:
            STRATUM_FAIL_COUNT[method] = 0
        STRATUM_FAIL_COUNT[method] = STRATUM_FAIL_COUNT[method] + 1
		
		
    
    
        if method not in STRATUM_ERROR_DATA:
            STRATUM_ERROR_DATA[method] = {}
        
        if err not in STRATUM_ERROR_DATA[method]:
            STRATUM_ERROR_DATA[method][err] = 0    
        STRATUM_ERROR_DATA[method][err] = STRATUM_ERROR_DATA[method][err] + 1
    
    else:
    
        if method not in STRATUM_SUCCESS_COUNT:
            STRATUM_SUCCESS_COUNT[method] = 0
        STRATUM_SUCCESS_COUNT[method] = STRATUM_SUCCESS_COUNT[method] + 1
		
		
    
    
        if method == "mining.subscribe":
            STRATUM_SUBSCRIBE_DATA = response["result"]
            WORK_ID = WORK_ID + 1
        elif method == "mining.set_target":            
            STRATUM_TARGET = bytes.fromhex(response["params"][0])
            print("Target changed to {}".format(response["params"][0]))
            
        elif method == "mining.notify":            
            STRATUM_NOTIFY_DATA = response["params"]              
            WORK_ID = WORK_ID + 1
            print("New job: {}".format(response["params"][0]))
    
        elif method == "mining.set_difficulty":            
            STRATUM_TARGET = bytes.fromhex(diff_to_target_alternate(float(response["params"][0])))
            print("Target changed to {}".format(response["params"][0]))
        elif method == "client.reconnect":            
            
            print("Server requested reconnection to {} {}".format(response["params"][0],response["params"][1]))
            STRATUM_HOSTNAME = response["params"][0]
            STRATUM_PORT = response["params"][1]
            if response["params"][2] is not None:   
                
                t = Timer(response["params"][2], stratum_reconnect)
                
                t.daemon = True
                
                t.start()                

    

def stratum_listen_lines():

    global STRATUM_SOCK
    
    while True:
        try:           

            sel = selectors.DefaultSelector()
            sel.register(STRATUM_SOCK, selectors.EVENT_READ)

            buffer = b""

            while True:
                events = sel.select()
                for key, mask in events:
                    if mask & selectors.EVENT_READ:
                        data = STRATUM_SOCK.recv(1024)
                        if not data:
                            
                            sel.unregister(STRATUM_SOCK)
                            STRATUM_SOCK.close()
                            raise Exception("Connection closed!") 
                            

                        buffer += data
                        while b'\n' in buffer:
                            line, buffer = buffer.split(b'\n', 1)
                            stratum_process_line(line)
        except Exception as e:
            print("Exception in stratum_listen_lines loop:")
            print(repr(e)) 
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            print(exc_type) 
            print(fname) 
            print(exc_tb.tb_lineno)
            traceback.print_exc()
            stratum_reconnect()
            time.sleep(5)


def stratum_connect():

    global STRATUM_SOCK,STRATUM_HOSTNAME,STRATUM_PORT,STRATUM_SSL

    STRATUM_SOCK = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    if STRATUM_SSL:
        sslfix_context = ssl._create_unverified_context()
        STRATUM_SOCK = sslfix_context.wrap_socket(STRATUM_SOCK)
    STRATUM_SOCK.connect((STRATUM_HOSTNAME, STRATUM_PORT))





_loop_start_val = {} 
def stratum_ocl_mine_ocvcoin(device_index):       
    
    global STRATUM_SUBSCRIBE_DATA,STRATUM_NOTIFY_DATA,STRATUM_TARGET,STRATUM_WORKER_NAMES,STRATUM_ID2METHOD,PYCL_QUEUE,PYCL_KERNEL,MAX_HASHRATE,WORK_ID,_loop_start_val
    

    if device_index not in _loop_start_val:
        _loop_start_val[device_index] = 1

    if device_index not in MAX_HASHRATE:
        MAX_HASHRATE[device_index] = 0
    
      

    local_work_items = abs(int(CONFIG[DEVICE_ID2GROUP[device_index]]["number_of_local_work_items"]))
    
    if local_work_items % 32 != 0:
        local_work_items = int(local_work_items / 32) * 32    
    if local_work_items == 0:
        local_work_items = 32
    
    global_work_size = abs(int(CONFIG[DEVICE_ID2GROUP[device_index]]["number_of_global_work_items"])) 
    if global_work_size % 256 != 0:
        global_work_size = (int(global_work_size / 256) + 1) * 256
    

    
    
    
    if CONFIG[DEVICE_ID2GROUP[device_index]]["loop_count"] != "auto":
        loop_count = abs(int(CONFIG[DEVICE_ID2GROUP[device_index]]["loop_count"]))
        if loop_count < 1:
            loop_count = 1
        elif loop_count > 256:
            loop_count = 256      
        
    else:
        
        loop_count = _loop_start_val[device_index]






        
    

    
    current_work_id = WORK_ID 
    current_target = STRATUM_TARGET    
    
    sub_details,extranonce1,extranonce2_size = STRATUM_SUBSCRIBE_DATA    
    
    job_id,prevhash,coinb1,coinb2,merkle_branch,version,nbits,ntime,clean_jobs = STRATUM_NOTIFY_DATA 
    
    extranonce2 = int2lehex(stratum_safe_extranonce2(), extranonce2_size).hex()
    
    block_header = build_block_header(STRATUM_NOTIFY_DATA,extranonce1,extranonce2)
    

    if current_work_id != WORK_ID:
        return
    





    
    block_header = bytes.fromhex(block_header)    
    
    

    


        
        
    printd(device_index,"Starting to mine job_id: "+str(job_id))
    
    
  
    

    start_hash = block_header[0:76]
    
    final_init_img = bytearray()

    i = 0
    while i < 27:
        start_hash = hashlib.sha512(start_hash).digest()
        final_init_img = final_init_img + start_hash
        i += 1

    # Create buffers    
    target_diff_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', current_target), blocking=True)
    init_img_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', final_init_img), blocking=True)
    block_header_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', block_header), blocking=True)
    
    output_buf_arr = array('B', b'\x00' * 32)    
    output_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], output_buf_arr, blocking=True)    
    
    

    
    MAX_HASHRATE[device_index] = 0    
    
    
    
    
    current_step = 0
    

    
    start_time = time.time()
    total_hashed = 0
    
    
    while True:
    
        
        
        calc_per_time = loop_count*global_work_size

        last_time_stamp = time.time()
        
        total_hashed = total_hashed + calc_per_time                            
        
        run_evt = PYCL_KERNEL[device_index](current_step, loop_count, target_diff_buf, init_img_buf, block_header_buf, output_buf).on(PYCL_QUEUE[device_index], global_work_size,lsize=local_work_items)

        output_bin, evt = buffer_to_pyarray(PYCL_QUEUE[device_index], output_buf, wait_for=run_evt, like=output_buf_arr) 

      
        

        # Wait for all events to complete
        evt.wait()
        
        nonce_bytes = output_bin.tobytes()



        if nonce_bytes[4] > 0:

            send_nonce = nonce_bytes[0:4][::-1].hex()

            #send_nonce = ''.join([send_nonce[i]+send_nonce[i+1] for i in range(0,len(send_nonce),2)][::-1])

            printd(device_index,"Found! Submitting: {}\n".format(nonce_bytes[0:4].hex()))  
  
            req_id = stratum_safe_get_request_id()
            
            STRATUM_ID2METHOD[req_id] = "mining.submit"
            
            payload = '{"params": ["'+STRATUM_WORKER_NAMES[device_index]+'", "'+str(job_id)+'", "'+ extranonce2 +'", "'+str(ntime)+'", "'+send_nonce+'"], "id": '+str(req_id)+', "method": "mining.submit"}\n'
            
            while True:
                try:            
                    stratum_safe_sendall(payload.encode(encoding="ascii",errors="ignore"))
                    break
                except Exception as e:
                    printd(device_index,"Exception in mining.submit loop:")
                    printd(device_index,repr(e))
                    time.sleep(5)
                    stratum_reconnect()
            
            clReleaseMemObject(output_buf)
            output_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], output_buf_arr, blocking=True) 



        current_timestamp = time.time()
        diff = current_timestamp - last_time_stamp
        
        hash_rate = int(calc_per_time / diff)
        
        
        
        
        
        total_diff = current_timestamp - start_time            
        total_hash_rate = int(total_hashed / total_diff)            
        
        if MAX_HASHRATE[device_index] < hash_rate:
            MAX_HASHRATE[device_index] = hash_rate
            
            
            
        printd(device_index,"Now: {}, Avg: {}, Max: {} hash/s (loop_count:{})".format(hash_rate,total_hash_rate,MAX_HASHRATE[device_index],loop_count))
        
         
        
        if current_step > 1 and (diff > 3  or diff < 1): 
            

            recommended_val = math.ceil((2 * loop_count) / diff)
            if recommended_val > 256:
                recommended_val = 256
            if recommended_val < 1:
                recommended_val = 1            
               
            
            if CONFIG[DEVICE_ID2GROUP[device_index]]["loop_count"] == "auto":                
                

                if loop_count != recommended_val:
                    printd(device_index,"Fixing check interval... Setting loop_count {} to {} ...".format(loop_count,recommended_val))
                loop_count = recommended_val
                _loop_start_val[device_index] = recommended_val
                          
                
                
                
        
        
        
        if WORK_ID != current_work_id:
            printd(device_index,"new work detected!")
            clReleaseMemObject(target_diff_buf)
            clReleaseMemObject(init_img_buf)
            clReleaseMemObject(block_header_buf)
            clReleaseMemObject(output_buf)        
            return
        current_step = current_step + 1
        
        if (current_step*global_work_size + global_work_size) > 0xFFFFFF:
            printd(device_index,"no more nonce!")
            clReleaseMemObject(target_diff_buf)
            clReleaseMemObject(init_img_buf)
            clReleaseMemObject(block_header_buf)
            clReleaseMemObject(output_buf)            
            return

        if current_target != STRATUM_TARGET:
            current_target = STRATUM_TARGET
            clReleaseMemObject(target_diff_buf)
            target_diff_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', current_target), blocking=True)            
            













def stratum_miner(device_index):
    
    global STRATUM_SUBSCRIBE_DATA,STRATUM_NOTIFY_DATA,STRATUM_TARGET,PYCL_CTX,PYCL_QUEUE,PYCL_PROGRAM,PYCL_KERNEL

    build_kernel(device_index)
    
    

    while True:
        try:     


            while STRATUM_SUBSCRIBE_DATA == None or STRATUM_NOTIFY_DATA == None or STRATUM_TARGET == None:
                print(".", end ="")
                time.sleep(0.05)

            
            stratum_ocl_mine_ocvcoin(device_index)                         
            
        except Exception as e:
            printd(device_index,"Exception in stratum_miner loop:")
            printd(device_index,repr(e)) 
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            printd(device_index,exc_type) 
            printd(device_index,fname) 
            printd(device_index,exc_tb.tb_lineno)
            traceback.print_exc()
            
            try:
                clReleaseKernel(PYCL_KERNEL[device_index])
            except Exception as e:
                pass
            try:
                clReleaseKernel(PYCL_PROGRAM[device_index])
            except Exception as e:
                pass                
            try:
                clReleaseKernel(PYCL_QUEUE[device_index])
            except Exception as e:
                pass                
            try:
                clReleaseKernel(PYCL_CTX[device_index])
            except Exception as e:
                pass                
                
                
                
                
                
            build_kernel(device_index)
            
            
            
            
            time.sleep(1)














_clbcc = 0
def check_latest_block():    
    
    global _clbcc,LATEST_TARGET_HEIGHT,LATEST_BLOCK_TEMPLATE,WORK_ID  

    if _clbcc % 200 == 0:
        LATEST_BLOCK_TEMPLATE = rpc_getblocktemplate()
        LATEST_TARGET_HEIGHT = int(LATEST_BLOCK_TEMPLATE["height"])-1
        WORK_ID = WORK_ID + 1
        _clbcc = 0
    else:    
        LATEST_TARGET_HEIGHT = rpc_getblockcount()
        
        if int(LATEST_BLOCK_TEMPLATE["height"]) <= LATEST_TARGET_HEIGHT:
            
            LATEST_BLOCK_TEMPLATE = rpc_getblocktemplate()
            LATEST_TARGET_HEIGHT = int(LATEST_BLOCK_TEMPLATE["height"])-1
            WORK_ID = WORK_ID + 1
            _clbcc = 0

    
    _clbcc = _clbcc + 1
    t = Timer(0.35, check_latest_block)
    
    t.daemon = True
    
    t.start()


  
  
try:
    
    request = urllib.request.Request("https://rpc.ocvcoin.com/",headers={'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.1.15 (KHTML, like Gecko)'})
    sslfix_context = ssl._create_unverified_context()        
    f = urllib.request.urlopen(request,context=sslfix_context,timeout=5)
    EXTRA_SEED = f.read()+bytes(str(f.info()),"utf-8")+bytes(str(time.time()),"ascii")
except Exception as e:
    try:
        EXTRA_SEED = bytes(str(time.time()),"ascii") + bytes(str(e.headers),"utf-8")
    except Exception as e:
        EXTRA_SEED = bytes(str(time.time()),"ascii")
    


def printd(device_index,i):

    now = datetime.now()
    dt_string = now.strftime("%Y-%m-%d %H:%M:%S")
    print("["+str(dt_string)+"] ["+DEVICE_NAMES[device_index]+"] "+str(i))



def check_addr(addr):
    
    version,addrbytes = decode_segwit_address("ocv", addr)
    
    if version != 0 and version != 1:
        return False
    if len(addrbytes) != 20 and len(addrbytes) != 32:
        return False
        
    return True
        







    
def create_coinbase_via_bech32_addr(height, bech32_addr, coinbasevalue, coinbasemsg, extra_output_script=None):
    #accepts bech32 & bech32m addresses
    
    
       
    
    coinbase = CTransaction()
    coinbase.vin.append(CTxIn(COutPoint(0, 0xffffffff), bytes(script_BIP34_coinbase_height(height))+hashlib.sha256(secrets.token_bytes(256)+EXTRA_SEED).digest()[:16]+bytes(coinbasemsg, 'utf-8')[:76], 0xffffffff))
    coinbaseoutput = CTxOut()

    coinbaseoutput.nValue = coinbasevalue
    
    address_decoded = decode_segwit_address("ocv", bech32_addr)

    if address_decoded[0] == 0:
        req_opcode = bytes(b'\x00')
    elif address_decoded[0] == 1:
        req_opcode = bytes(b'\x51')
    else:
        exit("address not supported!")
    
    
    coinbaseoutput.scriptPubKey = req_opcode + int2lehex(len(address_decoded[1]), 1) + bytes(address_decoded[1])
    
    coinbase.vout = [coinbaseoutput]
    if extra_output_script is not None:
        coinbaseoutput2 = CTxOut()
        coinbaseoutput2.nValue = 0
        coinbaseoutput2.scriptPubKey = extra_output_script
        coinbase.vout.append(coinbaseoutput2)
    coinbase.calc_sha256()
    return coinbase
def screen_clear():
   # for mac and linux(here, os.name is 'posix')
   if os.name == 'posix':
      _ = os.system('clear')
   else:
      # for windows platfrom
      _ = os.system('cls')

_print_norepeat_latest_input = ""
def print_norepeat(i):
    global _print_norepeat_latest_input
    if i != _print_norepeat_latest_input:
        _print_norepeat_latest_input = i
        print(i)





def rpc(method, params=None,rpc_index=0):
    """
    Make an RPC call to the Bitcoin Daemon JSON-HTTP server.

    Arguments:
        method (string): RPC method
        params: RPC arguments

    Returns:
        object: RPC response result.
    """

    rpc_id = random.getrandbits(32)
    data = json.dumps({"id": rpc_id, "method": method, "params": params}).encode()   

       
    
    if RPC_SERVERS[rpc_index][0] == OCVCOIN_PUBLIC_RPC_URL:
        if method == "getblocktemplate" or method == "getblockcount":
            request = urllib.request.Request(RPC_SERVERS[rpc_index][0]+"?method="+method)
        else:
            request = urllib.request.Request(RPC_SERVERS[rpc_index][0]+"?method="+method, data)
    else:
        auth = base64.encodebytes((RPC_SERVERS[rpc_index][1] + ":" + RPC_SERVERS[rpc_index][2]).encode()).decode().strip()
        request = urllib.request.Request(RPC_SERVERS[rpc_index][0], data, {"Authorization": "Basic {:s}".format(auth)})

    
    err_detected = False
    try:        
                
        sslfix_context = ssl._create_unverified_context()            
        f = urllib.request.urlopen(request,context=sslfix_context,timeout=5)
        response = json.loads(f.read())
        
    except Exception as e:
    
        #print("An exception occurred (RPC)") 
        #print(e)
        err_detected = True
        
    if not err_detected:
    
        if not 'id' in response:
            #print("id missing")
            #print(response)
            err_detected = True
            
        elif (RPC_SERVERS[rpc_index][0] != OCVCOIN_PUBLIC_RPC_URL or method == "submitblock") and response['id'] != rpc_id:
            #print("Invalid response id: got {}, expected {:u}".format(response['id'], rpc_id))
            #print(response)
            err_detected = True

        elif 'error' in response and response['error'] is not None:
            #print("RPC error: {:s}".format(json.dumps(response['error'])))
            err_detected = True
        
        elif not 'result' in response:
            #print("result missing")
            #print(response)
            err_detected = True





        
        
    if err_detected == True:
        if rpc_index == 0:
            if len(RPC_SERVERS) > 1:
                print_norepeat("Public RPC server sometimes not responding! Switching to backup RPC server!")
            else:
                print_norepeat("Public RPC server sometimes not responding! It is recommended to install Ocvcoin Core on your computer!")
        else:
            print_norepeat("The backup RPC server is also not responding! Please restart Ocvcoin Core!")
            
            
        return False
        



    return response['result']


def rpc_getblockcount():
    global LATEST_TARGET_HEIGHT
    
    divider = len(RPC_SERVERS)
    i = divider
    while True:
        rpcindex = i % divider
        #if i > divider:            
            #print("getblockcount" +str(i-divider)+ "th retry...")
            
        ret = rpc("getblockcount",rpc_index=rpcindex)        
            
        if ret != False:
            ret = int(ret)
            if ret >= LATEST_TARGET_HEIGHT:
                break
            #else:    
                #print("getblockcount low! rpc_index: "+str(rpcindex))
                #print("ret >= LATEST_TARGET_HEIGHT")
                #print(str(ret)+"    "+str(LATEST_TARGET_HEIGHT))
                
        #else:
            #print("getblockcount false! rpc_index: "+str(rpcindex))
            
        
        if rpcindex == (divider - 1):
            time.sleep(0.35)        
        
        i = i + 1
    
    return ret

def rpc_getblocktemplate():
    global LATEST_TARGET_HEIGHT
    
    divider = len(RPC_SERVERS)
    i = divider
    while True:
        rpcindex = i % divider
        #if i > divider:            
            #print("getblocktemplate" +str(i-divider)+ "th retry...")

        ret = rpc("getblocktemplate", [NORMAL_GBT_REQUEST_PARAMS],rpcindex)        
            
        if ret != False and "height" in ret:
            gbt_height = int(ret["height"])
            if gbt_height > LATEST_TARGET_HEIGHT:
                break
            #else:    
                #print("getblocktemplate height low! rpc_index: "+str(rpcindex))
                #print("gbt_height > LATEST_TARGET_HEIGHT")
                #print(str(gbt_height)+"    "+str(LATEST_TARGET_HEIGHT))
                
        #else:
            #print("getblocktemplate false! rpc_index: "+str(rpcindex))
            #print(ret)
            

        if rpcindex == (divider - 1):
            time.sleep(0.35)

        i = i + 1
    
    return ret

def rpc_submitblock(block_submission):
    
    
    divider = len(RPC_SERVERS)
    i = divider
    
    

    soft_errors = {}
    network_errors = {}
    
    while True:
        rpcindex = i % divider
        ret = rpc("submitblock", [block_submission],rpcindex)
        
        if ret is None:
            return
        elif ret == False:
            if rpcindex in network_errors[rpcindex]:
                network_errors[rpcindex] = network_errors[rpcindex] + 1
            else:
                network_errors[rpcindex] = 1
        else:        
            if rpcindex in soft_errors[rpcindex]:
                soft_errors[rpcindex] = soft_errors[rpcindex] + 1
            else:
                soft_errors[rpcindex] = 1        
        if len(soft_errors) == divider:
            raise TypeError("rpc_submitblock soft_errors") 
        
        if len(network_errors) == divider:
            is_max_err_count_reached = True
            for x in network_errors:
                is_max_err_count_reached = is_max_err_count_reached and (network_errors[x] > 4)
            if is_max_err_count_reached:
                raise TypeError("rpc_submitblock network_errors")
        
        for x in soft_errors:
            if soft_errors[x] > 8:
                raise TypeError("rpc_submitblock soft_error")

        for x in network_errors:
            if network_errors[x] > 8:
                raise TypeError("rpc_submitblock network_error")
        
        if rpcindex == (divider - 1):
            time.sleep(1)
        


        
        i = i + 1
    
    
    
    
def int2lehex(value, width):
    """
    Convert an unsigned integer to a little endian ASCII hex string.
    Args:
        value (int): value
        width (int): byte width
    Returns:
        string: ASCII hex string
    """

    return value.to_bytes(width, byteorder='little')


_loop_start_val = {} 
def ocl_mine_ocvcoin(device_index):       
    
    global PYCL_QUEUE,PYCL_KERNEL,MAX_HASHRATE,WORK_ID,LATEST_BLOCK_TEMPLATE,LATEST_TARGET_HEIGHT,_loop_start_val
    

    if device_index not in _loop_start_val:
        _loop_start_val[device_index] = 1

    if device_index not in MAX_HASHRATE:
        MAX_HASHRATE[device_index] = 0
    
      

    local_work_items = abs(int(CONFIG[DEVICE_ID2GROUP[device_index]]["number_of_local_work_items"]))
    
    if local_work_items % 32 != 0:
        local_work_items = int(local_work_items / 32) * 32    
    if local_work_items == 0:
        local_work_items = 32
    
    global_work_size = abs(int(CONFIG[DEVICE_ID2GROUP[device_index]]["number_of_global_work_items"])) 
    if global_work_size % 256 != 0:
        global_work_size = (int(global_work_size / 256) + 1) * 256
    

    
    
    
    if CONFIG[DEVICE_ID2GROUP[device_index]]["loop_count"] != "auto":
        loop_count = abs(int(CONFIG[DEVICE_ID2GROUP[device_index]]["loop_count"]))
        if loop_count < 1:
            loop_count = 1
        elif loop_count > 256:
            loop_count = 256      
        
    else:
        
        loop_count = _loop_start_val[device_index]






        
    

    
    current_work_id = WORK_ID  
    
    block_template = LATEST_BLOCK_TEMPLATE
    


        
        
    printd(device_index,"Starting to mine block: "+str(block_template["height"]))
    
    
    txlist = []

    for tx in block_template["transactions"]:
        txlist.append(tx["data"])

    
     
  

    coinbase = create_coinbase_via_bech32_addr(block_template["height"], CONFIG[DEVICE_ID2GROUP[device_index]]["reward_addr"], block_template["coinbasevalue"],DEVICE_NAMES[device_index].replace("FULL_PROFILE", "FP").replace("EMBEDDED_PROFILE", "EP").replace(": ", ":") + " {}/{}/{} {} {}".format(global_work_size,local_work_items,loop_count,MAX_HASHRATE[device_index],CURRENT_MINER_VERSION))

    block = create_block( coinbase=coinbase,  tmpl=block_template, txlist=txlist)
    
    
    if len(txlist) > 0:
        add_witness_commitment(block)

    new_block = block.serialize()
    
    block_header = new_block[0:80]  
    

    start_hash = block_header[0:76]
    
    final_init_img = bytearray()

    i = 0
    while i < 27:
        start_hash = hashlib.sha512(start_hash).digest()
        final_init_img = final_init_img + start_hash
        i += 1

    # Create buffers    
    target_diff_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', bytes.fromhex(block_template['target'])), blocking=True)
    init_img_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', final_init_img), blocking=True)
    block_header_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], array('B', block_header), blocking=True)
    
    output_buf_arr = array('B', b'\x00' * 32)    
    output_buf, _ = buffer_from_pyarray(PYCL_QUEUE[device_index], output_buf_arr, blocking=True)    
    
    

    
    MAX_HASHRATE[device_index] = 0    
    
    
    
    
    current_step = 0
    

    
    start_time = time.time()
    total_hashed = 0
    
    
    while True:
    
        
        
        calc_per_time = loop_count*global_work_size

        last_time_stamp = time.time()
        
        total_hashed = total_hashed + calc_per_time                            
        
        run_evt = PYCL_KERNEL[device_index](current_step, loop_count, target_diff_buf, init_img_buf, block_header_buf, output_buf).on(PYCL_QUEUE[device_index], global_work_size,lsize=local_work_items)

        output_bin, evt = buffer_to_pyarray(PYCL_QUEUE[device_index], output_buf, wait_for=run_evt, like=output_buf_arr) 

      
        

        # Wait for all events to complete
        evt.wait()
        
        nonce_bytes = output_bin.tobytes()



        if nonce_bytes[4] > 0:

            
            block_header = block_header[0:76] + nonce_bytes[0:4]



            submission = (block_header+new_block[80:]).hex()
            printd(device_index,"Found! Submitting: {}\n".format(submission[0:80]))  
  
            
            rpc_submitblock(submission)
            LATEST_TARGET_HEIGHT = int(block_template["height"])
            
            clReleaseMemObject(target_diff_buf)
            clReleaseMemObject(init_img_buf)
            clReleaseMemObject(block_header_buf)
            clReleaseMemObject(output_buf)
            
            return


        current_timestamp = time.time()
        diff = current_timestamp - last_time_stamp
        
        hash_rate = int(calc_per_time / diff)
        
        
        
        
        
        total_diff = current_timestamp - start_time            
        total_hash_rate = int(total_hashed / total_diff)            
        
        if MAX_HASHRATE[device_index] < hash_rate:
            MAX_HASHRATE[device_index] = hash_rate
            
            
            
        printd(device_index,"Now: {}, Avg: {}, Max: {} hash/s (loop_count:{})".format(hash_rate,total_hash_rate,MAX_HASHRATE[device_index],loop_count))
        
         
        
        if current_step > 1 and (diff > 3  or diff < 1): 
            

            recommended_val = math.ceil((2 * loop_count) / diff)
            if recommended_val > 256:
                recommended_val = 256
            if recommended_val < 1:
                recommended_val = 1            
               
            
            if CONFIG[DEVICE_ID2GROUP[device_index]]["loop_count"] == "auto":                
                

                if loop_count != recommended_val:
                    printd(device_index,"Fixing check interval... Setting loop_count {} to {} ...".format(loop_count,recommended_val))
                loop_count = recommended_val
                _loop_start_val[device_index] = recommended_val
                          
                
                
                
        
        
        
        if WORK_ID != current_work_id or int(block_template["height"]) <= LATEST_TARGET_HEIGHT:
            printd(device_index,"new work detected!")
            clReleaseMemObject(target_diff_buf)
            clReleaseMemObject(init_img_buf)
            clReleaseMemObject(block_header_buf)
            clReleaseMemObject(output_buf)        
            return
        current_step = current_step + 1
        
        if (current_step*global_work_size + global_work_size) > 0xFFFFFF:
            printd(device_index,"no more nonce!")
            clReleaseMemObject(target_diff_buf)
            clReleaseMemObject(init_img_buf)
            clReleaseMemObject(block_header_buf)
            clReleaseMemObject(output_buf)            
            return

            
            
            
    
            
def build_kernel(device_index):
    
    global PYCL_CTX,PYCL_QUEUE,PYCL_PROGRAM,PYCL_KERNEL,DEVICE_LIST

    try:
        cl_file = os.sep.join([os.path.dirname(os.path.abspath(__file__)),"ocv2_miner.cl"])
        printd(device_index,"Building source...")
        with open(cl_file, 'rb') as file:
            ocv2_miner_cl_source = file.read()

        bopts = bytes(CONFIG[DEVICE_ID2GROUP[device_index]]["build_flags"], 'ascii')

        PYCL_CTX[device_index] = clCreateContext(devices=[DEVICE_LIST[device_index]])
        PYCL_QUEUE[device_index] = clCreateCommandQueue(PYCL_CTX[device_index])
        PYCL_PROGRAM[device_index] = clCreateProgramWithSource(PYCL_CTX[device_index], ocv2_miner_cl_source).build(bopts)
        PYCL_KERNEL[device_index] = PYCL_PROGRAM[device_index]['search_hash']
        PYCL_KERNEL[device_index].argtypes = (cl_uint,cl_uint,cl_mem,cl_mem,cl_mem,cl_mem)
        printd(device_index,"Build complate!")

    except Exception as e:
        printd(device_index,"Build fail!")
        printd(device_index,repr(e))
        exit()

def standalone_miner(device_index):
    
    global LATEST_BLOCK_TEMPLATE,LATEST_TARGET_HEIGHT,PYCL_CTX,PYCL_QUEUE,PYCL_PROGRAM,PYCL_KERNEL

    build_kernel(device_index)
    
    

    while True:
        try:     
            while int(LATEST_BLOCK_TEMPLATE["height"]) <= LATEST_TARGET_HEIGHT:
                print(".", end ="")
                time.sleep(0.05)
            ocl_mine_ocvcoin(device_index)                         
            
        except Exception as e:
            printd(device_index,"Exception in standalone_miner loop:")
            printd(device_index,repr(e)) 
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            printd(device_index,exc_type) 
            printd(device_index,fname) 
            printd(device_index,exc_tb.tb_lineno)
            traceback.print_exc()
            
            try:
                clReleaseKernel(PYCL_KERNEL[device_index])
            except Exception as e:
                pass
            try:
                clReleaseKernel(PYCL_PROGRAM[device_index])
            except Exception as e:
                pass                
            try:
                clReleaseKernel(PYCL_QUEUE[device_index])
            except Exception as e:
                pass                
            try:
                clReleaseKernel(PYCL_CTX[device_index])
            except Exception as e:
                pass                
                
                
                
                
                
            build_kernel(device_index)
            
            
            
            
            time.sleep(1)


if __name__ == "__main__":

    screen_clear()
    IS_NEW_VERSION_AVAILABLE = False
    try:           
        request = urllib.request.Request("https://raw.githubusercontent.com/ocvcoin/gpuminer/main/version.txt")
        sslfix_context = ssl._create_unverified_context()        
        f = urllib.request.urlopen(request,context=sslfix_context,timeout=5)
        resp = f.read()
        if resp.decode('ascii').strip() != CURRENT_MINER_VERSION:
            print("")
            print("\033[91m\nNew version is available.\nTo update, visit: ocvcoin.com\n\033[00m")
            IS_NEW_VERSION_AVAILABLE = True
    except:
        print("\nNew version check failed. Skipping...\n")



    print("Ocvcoin Gpu Miner v"+str(CURRENT_MINER_VERSION)+" starting...")
    print(platform.uname())




    if os.name == 'nt':   
        config_location_path = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop')         
    elif os.name == 'posix':    
        config_location_path = os.path.join(os.path.join(os.path.expanduser('~')), 'Desktop') 

        if not os.path.exists(config_location_path) or not os.path.isdir(config_location_path):
            config_location_path = os.path.join(os.path.expanduser('~'))


    config_file = os.sep.join([config_location_path,"Ocvcoin_Gpu_Miner.ini"])


    CONFIG = configparser.ConfigParser()


    CONFIG.read(config_file) 
    
    print("Using %s" % _dll_filename)

    try:
        

        BUF_SIZE = 65536  # lets read stuff in 64kb chunks!

        md5 = hashlib.md5()
        sha1 = hashlib.sha1()
        sha256 = hashlib.sha256()

        with open(_dll_filename, 'rb') as f:
            while True:
                data = f.read(BUF_SIZE)
                if not data:
                    break
                md5.update(data)
                sha1.update(data)    
                sha256.update(data)
        
        print("MD5: {0}".format(md5.hexdigest()))
        print("SHA1: {0}".format(sha1.hexdigest()))    
        print("SHA256: {0}".format(sha256.hexdigest()))

        
    except Exception as e:
        pass

    
    
    print("Python: "+sys.version)

    
    print("\nSettings file: %s\n" % config_file)



    try:
        platforms = clGetPlatformIDs()
    except Exception as e: 
        print("Error!")
        print(repr(e))
        print("Make sure the GPU drivers are installed!")
        print("This could be the cause of this error")
        
        exit()

    if len(platforms) < 1:
        print("No platforms supporting OpenCL were found!")
        print("Make sure the GPU drivers are installed!")
        print("This could be the cause of this error")
        exit()

    default_configs = {}
  
    
    device_groups = {}
    DEVICE_LIST = {}
    DEVICE_NAMES = {}
    i = 0
    
    
    device_search_errors = []
    
    
    device_speeds = []
    
    
    for p in platforms:
        try:
            for d in clGetDeviceIDs(p):
                
                
                

                try:
                    max_compute_units = str(clGetDeviceInfo(d, cl_device_info.CL_DEVICE_MAX_COMPUTE_UNITS))
                except Exception as e:             
                    max_compute_units = str(type(e).__name__)

                try:
                    max_clock_freq = str(clGetDeviceInfo(d, cl_device_info.CL_DEVICE_MAX_CLOCK_FREQUENCY))
                except Exception as e:             
                    max_clock_freq = str(type(e).__name__)


                device_speeds.append(int(max_compute_units)*int(max_clock_freq))

                device_group_name = str(d.name) + " " + str(d.profile) + " " + max_compute_units + " " + max_clock_freq
                
                
                device_group_name = re.sub(re.compile('\s+', re.UNICODE), ' ', device_group_name).strip()
                

                
                if device_group_name not in device_groups:
                    device_groups[device_group_name] = []
                
                device_groups[device_group_name].append(i)
                
                

                device_full_name = "D"+str(len(device_groups[device_group_name]) - 1)+": "+ str(d.name) + " " + str(d.profile) + " " + max_compute_units + " " + max_clock_freq
                device_full_name = re.sub(re.compile('\s+', re.UNICODE), ' ', device_full_name).strip()                
                
                
                
                DEVICE_LIST[i] = d
                DEVICE_NAMES[i] = device_full_name


                



                default_configs[device_group_name] = {}
                default_configs[device_group_name]["build_flags"] = "-cl-fast-relaxed-math -cl-mad-enable -cl-no-signed-zeros"
                
                
                
                number_of_global_work_items = ((int(max_compute_units)*5120*2) / 40)
                if number_of_global_work_items % 256 != 0:
                    number_of_global_work_items = (int(number_of_global_work_items / 256) + 1) * 256
                
                
                default_configs[device_group_name]["number_of_global_work_items"] = str(int(number_of_global_work_items))
                default_configs[device_group_name]["number_of_local_work_items"] = "256"
                
                default_configs[device_group_name]["loop_count"] = "auto"
                
                default_configs[device_group_name]["reward_addr"] = ""
                
                
                i = i + 1
        except Exception as e:
            device_search_errors.append(repr(e))

    if len(device_groups) < 1:
        print("No devices supporting OpenCL were found!")
        print("Make sure the GPU drivers are installed!")
        print("This could be the cause of this error")
        print(device_search_errors)
        exit()

    DEVICE_ID2GROUP = {}

    new_group = {}
    for device_group_name in device_groups:
        new_key = str(len(device_groups[device_group_name]))+"x"+ device_group_name
        new_group[new_key] = device_groups[device_group_name]
        
              
        if new_key not in CONFIG:
            CONFIG[new_key] = default_configs[device_group_name]
        
        for device_index in device_groups[device_group_name]:
            DEVICE_NAMES[device_index] = DEVICE_NAMES[device_index].replace(device_group_name, new_key)
            DEVICE_ID2GROUP[device_index] = new_key
    device_groups = new_group
    del new_group
    del default_configs

    print("Device Group Selection")
    print("Please enter group number:")  
    i = 1
    for device_group_name in device_groups:
        print(str(i) + " - " + device_group_name)
        i = i + 1
    print(str(i) + " - ALL")    
    
    selected_group_number = input().strip()
            
    if selected_group_number.isnumeric() == False or int(selected_group_number) < 1 or int(selected_group_number) > (len(device_groups)+1):
        print("Invalid group number!")
        exit()        
    
    if int(selected_group_number) == (len(device_groups)+1):
        selected_group_name = "ALL"
    else:
        i = 1
        for device_group_name in device_groups:
            if int(selected_group_number) == i:
                selected_group_name = device_group_name
                break
            i = i + 1
    

  

    for device_group_name in device_groups:
    
        if selected_group_name == "ALL" or selected_group_name == device_group_name:
        
            

            if check_addr(CONFIG[device_group_name]["reward_addr"]):
                addr = CONFIG[device_group_name]["reward_addr"]
                print("Reward Address for "+device_group_name+": "+addr)
            else: 
                
                print("Requiring a reward address for "+device_group_name)
                print("\nYou can try wallet.ocvcoin.com to create a wallet and get an address.")
                addr = input("\nEnter your ocvcoin address:\n(you can right click & paste it)\n ")
                addr = addr.strip()


                if check_addr(addr) != True:
                    print("Wrong address. Address must be of bech32 type.")
                    print("(It should start with ocv1)")
                    exit()

                CONFIG[device_group_name]["reward_addr"] = addr        





    try:

        with open(config_file, 'w') as configfile_descp:
          CONFIG.write(configfile_descp)

    except Exception as e:
        print("Warning!")
        print("Failed to save settings to "+str(config_file))
        print(repr(e))


    for device_group_name in device_groups:
    
        if selected_group_name == "ALL" or selected_group_name == device_group_name:
            print(device_group_name)
            for k in CONFIG[device_group_name]:
                print(" " + k + " = " + CONFIG[device_group_name][k])
    
    






    PYCL_CTX = {}
    PYCL_QUEUE = {}
    PYCL_PROGRAM = {}
    PYCL_KERNEL = {}    
    threads_list = []












    print("Mining Method Selection")
    print("Please enter a method number:")

    mining_methods_list = ["POOL","POOL (SSL CONNECTION)","SOLO POOL","SOLO POOL (SSL CONNECTION)","SOLO (OUR PUBLIC RPC)"]
    
    i = 0
    for mining_method in mining_methods_list:
        print(str(i+1) + " - " + mining_method)
        i = i + 1
        
    
    selected_mining_method = int(input().strip())
    
    if selected_mining_method > len(mining_methods_list) or selected_mining_method < 1:
        print("invalid method number!")
        exit()
        
    
    if selected_mining_method < 5:
    
        plst = []


        #POOL NAME,HOSTNAME,PPLNS PORT,SOLO PORT,PPLNS SSL PORT,SOLO SSL PORT
        plst.append(["Mining4People.com Australia"   ,"au.mining4people.com" ,3376,3379,23376,23379 ])
        plst.append(["Mining4People.com Brazil"      ,"br.mining4people.com" ,3376,3379,23376,23379 ])
        plst.append(["Mining4People.com Germany"     ,"de.mining4people.com" ,3376,3379,23376,23379 ])
        plst.append(["Mining4People.com Canada"      ,"na.mining4people.com" ,3376,3379,23376,23379 ])
        plst.append(["Mining4People.com Finland"     ,"fi.mining4people.com" ,3376,3379,23376,23379 ])
        plst.append(["Mining4People.com India"       ,"in.mining4people.com" ,3376,3379,23376,23379 ])


        plst.append(["pool.PhalanxMine.com Sweden",	      "se-stratum.phalanxmine.com" ,5120,5120,25120,25120 ])	
        plst.append(["pool.PhalanxMine.com Singapore", 	  "sg-stratum.phalanxmine.com" ,5120,5120,25120,25120 ])	
        plst.append(["pool.PhalanxMine.com United States","us-stratum.phalanxmine.com" ,5120,5120,25120,25120 ])	
        plst.append(["pool.PhalanxMine.com Australia",	  "aus-stratum.phalanxmine.com",5120,5120,25120,25120 ])	
        plst.append(["pool.PhalanxMine.com Russia",	      "ru-stratum.phalanxmine.com" ,5120,5120,25120,25120 ])	
        plst.append(["pool.PhalanxMine.com Brazil", 	  "br-stratum.phalanxmine.com" ,5120,5120,25120,25120 ])	
        plst.append(["pool.PhalanxMine.com Germany",	  "de-stratum.phalanxmine.com" ,5120,5120,25120,25120 ])	
        plst.append(["pool.PhalanxMine.com Japan", 	      "jp-stratum.phalanxmine.com" ,5120,5120,25120,25120 ])


        print("Pool Selection")
        print("Please enter a pool number:")

        
        
        i = 0
        for pl in plst:
            print(str(i+1) + " - " + pl[0] + " " + mining_methods_list[selected_mining_method-1])
            i = i + 1
            
        
        selected_pool = int(input().strip())
        
        if selected_pool > len(plst) or selected_pool < 1:
            print("invalid pool number!")
            exit()
            
            
        device_speeds_total=0
        for _ds in device_speeds:
            device_speeds_total += _ds
         
        average_ds = device_speeds_total/len(device_speeds)            
        

        #rtx 4090 is 0.01
        pool_diff = float((average_ds * 0.01) / (128*2595))    
            
        STRATUM_HOSTNAME = plst[selected_pool-1][1]
        
        if selected_mining_method == 1:
            worker_password = "x,d={:.6f}".format(pool_diff)
            STRATUM_PORT = plst[selected_pool-1][2]
            STRATUM_SSL = False
            
        elif selected_mining_method == 2:
            worker_password = "x,d={:.6f}".format(pool_diff)
            STRATUM_PORT = plst[selected_pool-1][4]
            STRATUM_SSL = True
            
        if selected_mining_method == 3:
            worker_password = "x,d={:.6f},m=solo".format(pool_diff)
            STRATUM_PORT = plst[selected_pool-1][3]  
            STRATUM_SSL = False
            
        if selected_mining_method == 4:
            worker_password = "x,d={:.6f},m=solo".format(pool_diff)
            STRATUM_PORT = plst[selected_pool-1][5]
            STRATUM_SSL = True




        print("SSL: {}".format(STRATUM_SSL))
        print("HOST: {}".format(STRATUM_HOSTNAME))
        print("PORT: {}".format(STRATUM_PORT))        
        print("OPTIONS: {}".format(worker_password))









        STRATUM_SUBSCRIBE_DATA = None
        STRATUM_NOTIFY_DATA = None
        STRATUM_TARGET = None


        STRATUM_ID2METHOD = {}
        STRATUM_ERROR_DATA = {}
        STRATUM_FAIL_COUNT = {}
        STRATUM_SUCCESS_COUNT = {}

        STRATUM_WORKER_NAMES = {}

        STRATUM_CONNECT_LOCK = threading.Lock()
        STRATUM_EXTRANONCE2_LOCK = threading.Lock()
        STRATUM_RPC_ID_LOCK = threading.Lock()
        STRATUM_SENDALL_LOCK = threading.Lock()        

        stratum_reconnect()





        while True:
            try:            



                for device_group_name in device_groups:

                    if selected_group_name == "ALL" or selected_group_name == device_group_name:
                        
                        for device_index in device_groups[device_group_name]:                 

                            STRATUM_WORKER_NAMES[device_index] = re.sub('[^0-9a-zA-Z]+', '_', DEVICE_NAMES[device_index].replace("FULL_PROFILE", "FP").replace("EMBEDDED_PROFILE", "EP").replace(": ", ":"))
                            
                            STRATUM_WORKER_NAMES[device_index] = re.sub('[_]+', '_', STRATUM_WORKER_NAMES[device_index]).strip("_")
                            
                            STRATUM_WORKER_NAMES[device_index] = CONFIG[device_group_name]["reward_addr"]+"."+STRATUM_WORKER_NAMES[device_index]
                        
                            stratum_authorize(STRATUM_WORKER_NAMES[device_index],worker_password)



                
                break
            except Exception as e:
                print("Exception in stratum_authorize loop:")
                print(repr(e))
                time.sleep(5)
                stratum_reconnect()






                    
                    
                    
                    
                    
                    
        threads_list.append(Thread(target=stratum_listen_lines, args=[],daemon=True))            


        for device_group_name in device_groups:

            if selected_group_name == "ALL" or selected_group_name == device_group_name:
                
                for device_index in device_groups[device_group_name]:  
                                
                    threads_list.append(Thread(target=stratum_miner, args=[device_index],daemon=True))
                    
                    
                    
        threads_list.append(Thread(target=stratum_print_stats, args=[],daemon=True))            
















    else:

        try:

            ocvcoin_folder = False
            ocvcoin_configdata = False
            if os.name == 'nt':    
                ocvcoin_folder = os.sep.join([os.getenv('APPDATA'),"Ocvcoin"])      
            elif os.name == 'posix':
                ocvcoin_folder = os.path.expanduser(os.sep.join(["~",".ocvcoin"]))

            if ocvcoin_folder != False and os.path.isdir(ocvcoin_folder):
                
                ocvcoin_configfile = os.sep.join([ocvcoin_folder,"ocvcoin.conf"])
                if os.path.isfile(ocvcoin_configfile):
                    f = open(ocvcoin_configfile, "r")
                    ocvcoin_configdata = f.read()
                    f.close()
                    
                    check_rpc_config = re.search(rpc_check_regexp,ocvcoin_configdata)
                    if not check_rpc_config:
                        f = open(ocvcoin_configfile, "w")
                        ocvcoin_configdata = rpc_config+"\r\n\r\n\r\n\r\n"+ocvcoin_configdata
                        f.write(ocvcoin_configdata)
                        f.close()
                        print(ocvcoin_core_restart_warning)
                        
                    
                elif not os.path.exists(ocvcoin_configfile):
                    f = open(ocvcoin_configfile, "w")
                    ocvcoin_configdata = rpc_config+"\r\n\r\n\r\n\r\n"
                    f.write(ocvcoin_configdata)
                    f.close()
                    print(ocvcoin_core_restart_warning)
                    

            if ocvcoin_configdata != False:
                check_rpc_config = re.search(rpc_check_regexp,ocvcoin_configdata)
                if check_rpc_config:
                    print("We have detected that you have Ocvcoin Core installed on your system.")
                    print("While mining, it is recommended to keep Ocvcoin Core running!")
                    RPC_SERVERS.append(["http://127.0.0.1:8332","ocvcoinrpc",check_rpc_config.group(1)])

        except Exception as e:
            print("Ocvcoin Core Configurator Failed")
            print(repr(e))




        check_latest_block()



        
        
        
        for device_group_name in device_groups:
        
            if selected_group_name == "ALL" or selected_group_name == device_group_name:
                
                for device_index in device_groups[device_group_name]:            
                    
                    threads_list.append(Thread(target=standalone_miner, args=[device_index],daemon=True))












    # Start all threads
    for th in threads_list:
        th.start()
        
    
    # Wait for all of them to finish
    for th in threads_list:
        th.join()